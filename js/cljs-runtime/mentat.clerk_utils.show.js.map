{"version":3,"sources":["mentat/clerk_utils/show.cljc"],"mappings":";;AAgCA;;;;2CAAA,3CAAOA,8FAGJC;AAHH,AAIE,IAAMC,gBAAS,6CAAA,7CAACC;IACVC,aAAM,6CAAA,7CAACD;AADb,AAEE,OAACE,sBACA,WAAKC;AAAL,AACE,GAAe,AAACC,wBAAQD;AAElB,OAACE,+CAAO,CAAA,6DAAsB,AAACC,mDAAMP,cAASQ;;AAFpD,GAGM,EAAK,cAAAC,bAASL,oCACT,AAACM,cAAI,AAACC,oBAAUP;AACrB,IAAAQ,mBAAI,iBAAAC,eAAA,AAAAC,gBAAEZ;AAAF,AAAA,QAAAW,6CAAAA,gDAAAA,LAAQT,4BAAAA;;AAAZ,AAAA,oBAAAQ;AAAAA;;AACI,IAAMG,IAAE,AAACT,+CAAO,CAAA,6DAAsB,AAACC,mDAAMP,cAASQ;AAAtD,AACE,AAACD,mDAAML,WAAMc,gBAAMZ,EAAEW;;AACrBA;;;AARZ,AASYX;;;;GAAIL;;AAEvB,AAAckB,sCACZ,AAACC,6CAAKC,eAAKrB","names":["mentat.clerk-utils.show/stable-hash-form","form","!counter","cljs.core.atom","!syms","clojure.walk/postwalk","x","cljs.core/regexp?","cljs.core.symbol","cljs.core.swap_BANG_","cljs.core/inc","cljs.core/Symbol","cljs.core/not","cljs.core/namespace","or__5045__auto__","fexpr__48407","cljs.core/deref","y","cljs.core/assoc","mentat.clerk-utils.show/stable-hash","cljs.core.comp","cljs.core/hash"],"sourcesContent":["(ns mentat.clerk-utils.show\n  \"Show utilities for Clerk.\"\n  (:require [applied-science.js-interop :as j]\n            [clojure.walk :as walk]\n            [nextjournal.clerk #?(:clj :as :cljs :as-alias) clerk]\n            #?@(:cljs [[nextjournal.clerk.render]]))\n  #?(:cljs\n     (:require-macros mentat.clerk-utils.show)))\n\n(defmacro show-sci\n  \"Returns a form that executes all `exprs` in Clerk's SCI environment and renders\n  the final form. If the final form evaluates to a vector, the vector is\n  interpreted as a Reagent component.\n\n  Else, the form is presented with `[v/inspect form]`. (To present a vector,\n  manually wrap the final form in `[v/inspect ,,,]`.)\"\n  [& exprs]\n  (when-not (:ns &env)\n    `(clerk/with-viewer\n       {:transform-fn clerk/mark-presented\n        :render-fn '(fn [_#]\n                      (let [result# (do ~@exprs)]\n                        (v/html\n                         (if (vector? result#)\n                           result#\n                           [v/inspect result#]))))}\n       {})))\n\n;; ## Clerk ClojureScript/Reagent viewer\n;;\n;; (for using compiled ClojureScript in a notebook)\n\n(defn- stable-hash-form\n  \"Replaces gensyms and regular expressions with stable symbols for consistent\n  hashing.\"\n  [form]\n  (let [!counter (atom 0)\n        !syms (atom {})]\n    (walk/postwalk\n     (fn [x]\n       (cond #?(:cljs (regexp? x)\n                :clj  (instance? java.util.regex.Pattern x))\n             (symbol (str \"stable-regexp-\" (swap! !counter inc)))\n             (and (symbol? x)\n                  (not (namespace x)))\n             (or (@!syms x)\n                 (let [y (symbol (str \"stable-symbol-\" (swap! !counter inc)))]\n                   (swap! !syms assoc x y)\n                   y))\n             :else x)) form)))\n\n(def ^:no-doc stable-hash\n  (comp hash stable-hash-form))\n\n;; TODO we can really win if we can figure out some way to call this code very\n;; naturally from SCI.\n\n#?(:clj\n   (def ^:no-doc loading-viewer\n     {:transform-fn nextjournal.clerk/mark-presented\n      :render-fn\n      '(fn render-var [fn-name]\n         ;; ensure that a reagent atom exists for this fn\n         (applied-science.js-interop/update-in!\n          js/window\n          [:clerk-cljs fn-name]\n          (fn [x] (or x (reagent.core/atom {:loading? true}))))\n         (let [res @(j/get-in js/window [:clerk-cljs fn-name])]\n           (if (:loading? res)\n             [:div.my-2 {:style {:color \"rgba(0,0,0,0.5)\"}} \"Loading...\"]\n             (let [result (try ((:f res))\n                               (catch js/Error e\n                                 (js/console.error e)\n                                 [nextjournal.clerk.render/error-view e]))]\n\n               (if (and (vector? result)\n                        (not (:inspect (meta result))))\n                 [:div.my-1 result]\n                 [nextjournal.clerk.render/inspect result])))))}))\n\n(defmacro show-cljs\n  \"Evaluate expressions in ClojureScript instead of Clojure.\n\n  Result is treated as hiccup if it is a vector (unless tagged with ^:inspect),\n  otherwise passed to Clerk's `inspect`.\"\n  ([] nil)\n  ([& exprs]\n   (let [[defns others] ((juxt filter remove)\n                         #(when (seq? %)\n                            (= 'defn (first %)))\n                         exprs)\n         body (if (empty? others)\n                [(second (last defns))]\n                others)\n         fn-name (str *ns* \"-\" (mentat.clerk-utils.show/stable-hash others))]\n     (if (:ns &env)\n       ;; in ClojureScript, define a function\n       `(do ~@defns\n            (let [f# (fn [] ~@body)]\n              (j/update-in! ~'js/window [:clerk-cljs ~fn-name]\n                            (fn [x#]\n                              (cond (not x#) (reagent.core/atom {:f f#})\n                                    (:loading? @x#) (doto x# (reset! {:f f#}))\n                                    :else x#)))))\n       ;; in Clojure, return a map with a reference to the fully qualified sym\n       `(clerk/with-viewer loading-viewer ~fn-name)))))\n"]}