import "./cljs_env.js";
shadow$provide.module$node_modules$three$src$renderers$webgl$WebGLUniformsGroups=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.WebGLUniformsGroups=function(gl,info$jscomp$0,capabilities,state){function prepareUniformsGroup(uniformsGroup){const uniforms=uniformsGroup.uniforms;let offset=0;for(let i=0,l=uniforms.length;i<l;i++){const uniform=uniforms[i];var JSCompiler_object_inline_boundary_5865=0,JSCompiler_object_inline_storage_5866=0;var chunkOffset=
Array.isArray(uniform.value)?uniform.value:[uniform.value];for(let j=0,jl=chunkOffset.length;j<jl;j++){var info=getUniformSize(chunkOffset[j]);JSCompiler_object_inline_boundary_5865+=info.boundary;JSCompiler_object_inline_storage_5866+=info.storage}uniform.__data=new Float32Array(JSCompiler_object_inline_storage_5866/Float32Array.BYTES_PER_ELEMENT);uniform.__offset=offset;0<i&&(chunkOffset=offset%16,info=16-chunkOffset,0!==chunkOffset&&0>info-JSCompiler_object_inline_boundary_5865&&(offset+=16-chunkOffset,
uniform.__offset=offset));offset+=JSCompiler_object_inline_storage_5866}chunkOffset=offset%16;0<chunkOffset&&(offset+=16-chunkOffset);uniformsGroup.__size=offset;uniformsGroup.__cache={};return this}function getUniformSize(value){const info={boundary:0,storage:0};"number"===typeof value?(info.boundary=4,info.storage=4):value.isVector2?(info.boundary=8,info.storage=8):value.isVector3||value.isColor?(info.boundary=16,info.storage=12):value.isVector4?(info.boundary=16,info.storage=16):value.isMatrix3?
(info.boundary=48,info.storage=48):value.isMatrix4?(info.boundary=64,info.storage=64):value.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",value);return info}function onUniformsGroupsDispose(event){event=event.target;event.removeEventListener("dispose",onUniformsGroupsDispose);const index=allocatedBindingPoints.indexOf(event.__bindingPointIndex);allocatedBindingPoints.splice(index,
1);gl.deleteBuffer(buffers[event.id]);delete buffers[event.id];delete updateList[event.id]}let buffers={},updateList={},allocatedBindingPoints=[];const maxBindingPoints=capabilities.isWebGL2?gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS):0;return{bind:function(uniformsGroup,program){state.uniformBlockBinding(uniformsGroup,program.program)},update:function(uniformsGroup,program){var buffer=buffers[uniformsGroup.id];if(void 0===buffer){prepareUniformsGroup(uniformsGroup);a:{for(buffer=0;buffer<maxBindingPoints;buffer++)if(-1===
allocatedBindingPoints.indexOf(buffer)){allocatedBindingPoints.push(buffer);break a}console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");buffer=0}uniformsGroup.__bindingPointIndex=buffer;var buffer$jscomp$0=gl.createBuffer(),size=uniformsGroup.__size,usage=uniformsGroup.usage;gl.bindBuffer(gl.UNIFORM_BUFFER,buffer$jscomp$0);gl.bufferData(gl.UNIFORM_BUFFER,size,usage);gl.bindBuffer(gl.UNIFORM_BUFFER,null);gl.bindBufferBase(gl.UNIFORM_BUFFER,buffer,
buffer$jscomp$0);buffer=buffer$jscomp$0;buffers[uniformsGroup.id]=buffer;uniformsGroup.addEventListener("dispose",onUniformsGroupsDispose)}state.updateUBOMapping(uniformsGroup,program.program);program=info$jscomp$0.render.frame;if(updateList[uniformsGroup.id]!==program){buffer=uniformsGroup.uniforms;buffer$jscomp$0=uniformsGroup.__cache;gl.bindBuffer(gl.UNIFORM_BUFFER,buffers[uniformsGroup.id]);for(let i=0,il=buffer.length;i<il;i++){size=buffer[i];a:{usage=i;var cache=buffer$jscomp$0,value=size.value;
if(void 0===cache[usage]){if("number"===typeof value)cache[usage]=value;else{value=Array.isArray(value)?value:[value];var tempValues=[];for(var i$jscomp$0=0;i$jscomp$0<value.length;i$jscomp$0++)tempValues.push(value[i$jscomp$0].clone());cache[usage]=tempValues}usage=!0}else{if("number"===typeof value){if(cache[usage]!==value){cache[usage]=value;usage=!0;break a}}else for(usage=Array.isArray(cache[usage])?cache[usage]:[cache[usage]],cache=Array.isArray(value)?value:[value],value=0;value<usage.length;value++)if(tempValues=
usage[value],!1===tempValues.equals(cache[value])){tempValues.copy(cache[value]);usage=!0;break a}usage=!1}}if(!0===usage){usage=size.__offset;cache=Array.isArray(size.value)?size.value:[size.value];value=0;for(tempValues=0;tempValues<cache.length;tempValues++){i$jscomp$0=cache[tempValues];const info=getUniformSize(i$jscomp$0);"number"===typeof i$jscomp$0?(size.__data[0]=i$jscomp$0,gl.bufferSubData(gl.UNIFORM_BUFFER,usage+value,size.__data)):i$jscomp$0.isMatrix3?(size.__data[0]=i$jscomp$0.elements[0],
size.__data[1]=i$jscomp$0.elements[1],size.__data[2]=i$jscomp$0.elements[2],size.__data[3]=i$jscomp$0.elements[0],size.__data[4]=i$jscomp$0.elements[3],size.__data[5]=i$jscomp$0.elements[4],size.__data[6]=i$jscomp$0.elements[5],size.__data[7]=i$jscomp$0.elements[0],size.__data[8]=i$jscomp$0.elements[6],size.__data[9]=i$jscomp$0.elements[7],size.__data[10]=i$jscomp$0.elements[8],size.__data[11]=i$jscomp$0.elements[0]):(i$jscomp$0.toArray(size.__data,value),value+=info.storage/Float32Array.BYTES_PER_ELEMENT)}gl.bufferSubData(gl.UNIFORM_BUFFER,
usage,size.__data)}}gl.bindBuffer(gl.UNIFORM_BUFFER,null);updateList[uniformsGroup.id]=program}},dispose:function(){for(const id in buffers)gl.deleteBuffer(buffers[id]);allocatedBindingPoints=[];buffers={};updateList={}}}}}
//# sourceMappingURL=module$node_modules$three$src$renderers$webgl$WebGLUniformsGroups.js.map
