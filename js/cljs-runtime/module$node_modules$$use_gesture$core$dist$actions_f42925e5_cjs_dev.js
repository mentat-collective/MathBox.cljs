import "./cljs_env.js";
shadow$provide.module$node_modules$$use_gesture$core$dist$actions_f42925e5_cjs_dev=function(global,require,module,exports){function _defineProperty(obj,key,value){key in obj?Object.defineProperty(obj,key,{value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value;return obj}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,
sym).enumerable}));keys.push.apply(keys,symbols)}return keys}function _objectSpread2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key])}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}return target}
function capitalize(string){return string?string[0].toUpperCase()+string.slice(1):""}function hasCapture(capture=!1,actionKey){return capture&&!actionsWithoutCaptureSupported.includes(actionKey)}function isTouch(event){return"touches"in event}function getPointerType(event){return isTouch(event)?"touch":"pointerType"in event?event.pointerType:"mouse"}function getCurrentTargetTouchList(event){return Array.from(event.touches).filter(e=>{var _event$currentTarget,_event$currentTarget$;return e.target===
event.currentTarget||(null===(_event$currentTarget=event.currentTarget)||void 0===_event$currentTarget?void 0:null===(_event$currentTarget$=_event$currentTarget.contains)||void 0===_event$currentTarget$?void 0:_event$currentTarget$.call(_event$currentTarget,e.target))})}function getValueEvent(event){return isTouch(event)?("touchend"===event.type||"touchcancel"===event.type?event.changedTouches:event.targetTouches)[0]:event}function distanceAngle(P1,P2){const dx=P2.clientX-P1.clientX,dy=P2.clientY-
P1.clientY;return{angle:-(180*Math.atan2(dx,dy))/Math.PI,distance:Math.hypot(dx,dy),origin:[(P2.clientX+P1.clientX)/2,(P2.clientY+P1.clientY)/2]}}function touchDistanceAngle(event,ids){const [P1,P2]=Array.from(event.touches).filter(touch=>ids.includes(touch.identifier));return distanceAngle(P1,P2)}function pointerId(event){const valueEvent=getValueEvent(event);return isTouch(event)?valueEvent.identifier:valueEvent.pointerId}function pointerValues(event){event=getValueEvent(event);return[event.clientX,
event.clientY]}function wheelValues(event){let {deltaX,deltaY,deltaMode}=event;1===deltaMode?(deltaX*=40,deltaY*=40):2===deltaMode&&(deltaX*=800,deltaY*=800);return[deltaX,deltaY]}function call(v,...args){return"function"===typeof v?v(...args):v}function noop(){}function selectAxis([dx,dy],threshold){dx=Math.abs(dx);dy=Math.abs(dy);if(dx>dy&&dx>threshold)return"x";if(dy>dx&&dy>threshold)return"y"}function clampStateInternalMovementToBounds(state){const [ox,oy]=state.overflow,[dx,dy]=state._delta,
[dirx,diry]=state._direction;if(0>ox&&0<dx&&0>dirx||0<ox&&0>dx&&0<dirx)state._movement[0]=state._movementBound[0];if(0>oy&&0<dy&&0>diry||0<oy&&0>dy&&0<diry)state._movement[1]=state._movementBound[1]}var maths=require("module$node_modules$$use_gesture$core$dist$maths_0c237923_cjs_dev");const EVENT_TYPE_MAP={pointer:{start:"down",change:"move",end:"up"},mouse:{start:"down",change:"move",end:"up"},touch:{start:"start",change:"move",end:"end"},gesture:{start:"start",change:"change",end:"end"}},actionsWithoutCaptureSupported=
["enter","leave"],pointerCaptureEvents=["gotpointercapture","lostpointercapture"];class Engine{constructor(ctrl,args,key){this.ctrl=ctrl;this.args=args;this.key=key;this.state||(this.state={},this.computeValues([0,0]),this.computeInitial(),this.init&&this.init(),this.reset())}get state(){return this.ctrl.state[this.key]}set state(state){this.ctrl.state[this.key]=state}get shared(){return this.ctrl.state.shared}get eventStore(){return this.ctrl.gestureEventStores[this.key]}get timeoutStore(){return this.ctrl.gestureTimeoutStores[this.key]}get config(){return this.ctrl.config[this.key]}get sharedConfig(){return this.ctrl.config.shared}get handler(){return this.ctrl.handlers[this.key]}reset(){const {state,
shared,ingKey,args}=this;shared[ingKey]=state._active=state.active=state._blocked=state._force=!1;state._step=[!1,!1];state.intentional=!1;state._movement=[0,0];state._distance=[0,0];state._direction=[0,0];state._delta=[0,0];state._bounds=[[-Infinity,Infinity],[-Infinity,Infinity]];state.args=args;state.axis=void 0;state.memo=void 0;state.elapsedTime=0;state.direction=[0,0];state.distance=[0,0];state.overflow=[0,0];state._movementBound=[!1,!1];state.velocity=[0,0];state.movement=[0,0];state.delta=
[0,0];state.timeStamp=0}start(event){const state=this.state,config=this.config;state._active||(this.reset(),this.computeInitial(),state._active=!0,state.target=event.target,state.currentTarget=event.currentTarget,state.lastOffset=config.from?call(config.from,state):state.offset,state.offset=state.lastOffset);state.startTime=state.timeStamp=event.timeStamp}computeValues(values){const state=this.state;state._values=values;state.values=this.config.transform(values)}computeInitial(){const state=this.state;
state._initial=state._values;state.initial=state.values}compute(event){const {state,config,shared}=this;state.args=this.args;var dt=0;if(event){state.event=event;config.preventDefault&&event.cancelable&&state.event.preventDefault();state.type=event.type;shared.touches=this.ctrl.pointerIds.size||this.ctrl.touchIds.size;shared.locked=!!document.pointerLockElement;dt=Object;var JSCompiler_temp_const=dt.assign,payload={};"buttons"in event&&(payload.buttons=event.buttons);if("shiftKey"in event){const {shiftKey,
altKey,metaKey,ctrlKey}=event;Object.assign(payload,{shiftKey,altKey,metaKey,ctrlKey})}JSCompiler_temp_const.call(dt,shared,payload);shared.down=shared.pressed=1===shared.buttons%2||0<shared.touches;dt=event.timeStamp-state.timeStamp;state.timeStamp=event.timeStamp;state.elapsedTime=state.timeStamp-state.startTime}state._active&&(JSCompiler_temp_const=state._delta.map(Math.abs),maths.V.addTo(state._distance,JSCompiler_temp_const));this.axisIntent&&this.axisIntent(event);const [_m0,_m1]=state._movement,
[t0,t1]=config.threshold,{_step,values}=state;config.hasCustomTransform?(!1===_step[0]&&(_step[0]=Math.abs(_m0)>=t0&&values[0]),!1===_step[1]&&(_step[1]=Math.abs(_m1)>=t1&&values[1])):(!1===_step[0]&&(_step[0]=Math.abs(_m0)>=t0&&Math.sign(_m0)*t0),!1===_step[1]&&(_step[1]=Math.abs(_m1)>=t1&&Math.sign(_m1)*t1));state.intentional=!1!==_step[0]||!1!==_step[1];if(state.intentional){JSCompiler_temp_const=[0,0];if(config.hasCustomTransform){const [v0,v1]=values;JSCompiler_temp_const[0]=!1!==_step[0]?v0-
_step[0]:0;JSCompiler_temp_const[1]=!1!==_step[1]?v1-_step[1]:0}else JSCompiler_temp_const[0]=!1!==_step[0]?_m0-_step[0]:0,JSCompiler_temp_const[1]=!1!==_step[1]?_m1-_step[1]:0;this.restrictToAxis&&!state._blocked&&this.restrictToAxis(JSCompiler_temp_const);payload=state.offset;var gestureIsActive=state._active&&!state._blocked||state.active;gestureIsActive&&(state.first=state._active&&!state.active,state.last=!state._active&&state.active,state.active=shared[this.ingKey]=state._active,event&&(state.first&&
("bounds"in config&&(state._bounds=call(config.bounds,state)),this.setup&&this.setup()),state.movement=JSCompiler_temp_const,this.computeOffset()));var [ox,oy]=state.offset,[[x0,x1],[y0,y1]]=state._bounds;state.overflow=[ox<x0?-1:ox>x1?1:0,oy<y0?-1:oy>y1?1:0];state._movementBound[0]=state.overflow[0]?!1===state._movementBound[0]?state._movement[0]:state._movementBound[0]:!1;state._movementBound[1]=state.overflow[1]?!1===state._movementBound[1]?state._movement[1]:state._movementBound[1]:!1;state.offset=
maths.computeRubberband(state._bounds,state.offset,state._active?config.rubberband||[0,0]:[0,0]);state.delta=maths.V.sub(state.offset,payload);this.computeMovement();gestureIsActive&&(!state.last||32<dt)&&(state.delta=maths.V.sub(state.offset,payload),event=state.delta.map(Math.abs),maths.V.addTo(state.distance,event),state.direction=state.delta.map(Math.sign),state._direction=state._delta.map(Math.sign),!state.first&&0<dt&&(state.velocity=[event[0]/dt,event[1]/dt]))}}emit(){const state=this.state;
var shared=this.shared;const config=this.config;state._active||this.clean();if(!state._blocked&&state.intentional||state._force||config.triggerAllEvents)shared=this.handler(_objectSpread2(_objectSpread2(_objectSpread2({},shared),state),{},{[this.aliasKey]:state.values})),void 0!==shared&&(state.memo=shared)}clean(){this.eventStore.clean();this.timeoutStore.clean()}}class CoordinatesEngine extends Engine{constructor(...args){super(...args);_defineProperty(this,"aliasKey","xy")}reset(){super.reset();
this.state.axis=void 0}init(){this.state.offset=[0,0];this.state.lastOffset=[0,0]}computeOffset(){this.state.offset=maths.V.add(this.state.lastOffset,this.state.movement)}computeMovement(){this.state.movement=maths.V.sub(this.state.offset,this.state.lastOffset)}axisIntent(event){const state=this.state,config=this.config;!state.axis&&event&&(event="object"===typeof config.axisThreshold?config.axisThreshold[getPointerType(event)]:config.axisThreshold,state.axis=selectAxis(state._movement,event));state._blocked=
(config.lockDirection||!!config.axis)&&!state.axis||!!config.axis&&config.axis!==state.axis}restrictToAxis(v){if(this.config.axis||this.config.lockDirection)switch(this.state.axis){case "x":v[1]=0;break;case "y":v[0]=0}}}const identity=v=>v;require={enabled(value=!0){return value},eventOptions(value,_k,config){return _objectSpread2(_objectSpread2({},config.shared.eventOptions),value)},preventDefault(value=!1){return value},triggerAllEvents(value=!1){return value},rubberband(value=0){switch(value){case !0:return[.15,
.15];case !1:return[0,0];default:return maths.V.toVector(value)}},from(value){if("function"===typeof value)return value;if(null!=value)return maths.V.toVector(value)},transform(value,_k,config){value=value||config.shared.transform;this.hasCustomTransform=!!value;const originalTransform=value||identity;return v=>{v=originalTransform(v);isFinite(v[0])&&isFinite(v[1])||console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${v[0]},${[1]}]`);return v}},threshold(value){return maths.V.toVector(value,
0)}};Object.assign(require,{domTarget(value){if(void 0!==value)throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");return NaN},lockDirection(value){if(void 0!==value)throw Error("[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`");return NaN},initial(value){if(void 0!==value)throw Error("[@use-gesture]: `initial` option has been renamed to `from`.");return NaN}});const coordinatesConfigResolver=_objectSpread2(_objectSpread2({},
require),{},{axis(_v,_k,{axis}){this.lockDirection="lock"===axis;if(!this.lockDirection)return axis},axisThreshold(value=0){return value},bounds(value={}){if("function"===typeof value)return state=>coordinatesConfigResolver.bounds(value(state));if("current"in value)return()=>value.current;if("function"===typeof HTMLElement&&value instanceof HTMLElement)return value;const {left=-Infinity,right=Infinity,top=-Infinity,bottom=Infinity}=value;return[[left,right],[top,bottom]]}}),KEYS_DELTA_MAP={ArrowRight:(factor=
1)=>[10*factor,0],ArrowLeft:(factor=1)=>[-10*factor,0],ArrowUp:(factor=1)=>[0,-10*factor],ArrowDown:(factor=1)=>[0,10*factor]};class DragEngine extends CoordinatesEngine{constructor(...args){super(...args);_defineProperty(this,"ingKey","dragging")}reset(){super.reset();const state=this.state;state._pointerId=void 0;state._pointerActive=!1;state._keyboardActive=!1;state._preventScroll=!1;state._delayed=!1;state.swipe=[0,0];state.tap=!1;state.canceled=!1;state.cancel=this.cancel.bind(this)}setup(){const state=
this.state;if(state._bounds instanceof HTMLElement){const boundRect=state._bounds.getBoundingClientRect(),targetRect=state.currentTarget.getBoundingClientRect();state._bounds=coordinatesConfigResolver.bounds({left:boundRect.left-targetRect.left+state.offset[0],right:boundRect.right-targetRect.right+state.offset[0],top:boundRect.top-targetRect.top+state.offset[1],bottom:boundRect.bottom-targetRect.bottom+state.offset[1]})}}cancel(){const state=this.state;state.canceled||(state.canceled=!0,state._active=
!1,setTimeout(()=>{this.compute();this.emit()},0))}setActive(){this.state._active=this.state._pointerActive||this.state._keyboardActive}clean(){this.pointerClean();this.state._pointerActive=!1;this.state._keyboardActive=!1;super.clean()}pointerDown(event){const config=this.config,state=this.state;if(null==event.buttons||(Array.isArray(config.pointerButtons)?config.pointerButtons.includes(event.buttons):-1===config.pointerButtons||config.pointerButtons===event.buttons)){var ctrlIds=this.ctrl.setEventIds(event);
config.pointerCapture&&event.target.setPointerCapture(event.pointerId);ctrlIds&&1<ctrlIds.size&&state._pointerActive||(this.start(event),this.setupPointer(event),state._pointerId=pointerId(event),state._pointerActive=!0,this.computeValues(pointerValues(event)),this.computeInitial(),config.preventScrollAxis&&"mouse"!==getPointerType(event)?(state._active=!1,this.setupScrollPrevention(event)):0<config.delay?(this.setupDelayTrigger(event),config.triggerAllEvents&&(this.compute(event),this.emit())):this.startPointerDrag(event))}}startPointerDrag(event){const state=
this.state;state._active=!0;state._preventScroll=!0;state._delayed=!1;this.compute(event);this.emit()}pointerMove(event){const state=this.state,config=this.config;if(state._pointerActive&&(state.type!==event.type||event.timeStamp!==state.timeStamp)){var id=pointerId(event);if(void 0===state._pointerId||id===state._pointerId)id=pointerValues(event),document.pointerLockElement===event.target?state._delta=[event.movementX,event.movementY]:(state._delta=maths.V.sub(id,state._values),this.computeValues(id)),
maths.V.addTo(state._movement,state._delta),this.compute(event),state._delayed&&state.intentional?(this.timeoutStore.remove("dragDelay"),state.active=!1,this.startPointerDrag(event)):config.preventScrollAxis&&!state._preventScroll?state.axis&&(state.axis===config.preventScrollAxis||"xy"===config.preventScrollAxis?(state._active=!1,this.clean()):(this.timeoutStore.remove("startPointerDrag"),this.startPointerDrag(event))):this.emit()}}pointerUp(event){this.ctrl.setEventIds(event);try{this.config.pointerCapture&&
event.target.hasPointerCapture(event.pointerId)&&event.target.releasePointerCapture(event.pointerId)}catch(_unused){console.warn("[@use-gesture]: If you see this message, it's likely that you're using an outdated version of `@react-three/fiber`. \n\nPlease upgrade to the latest version.")}const state=this.state,config=this.config;if(state._active&&state._pointerActive){var id=pointerId(event);if(void 0===state._pointerId||id===state._pointerId){this.state._pointerActive=!1;this.setActive();this.compute(event);
var [dx,dy]=state._distance;state.tap=dx<=config.tapsThreshold&&dy<=config.tapsThreshold;if(state.tap&&config.filterTaps)state._force=!0;else{const [dirx,diry]=state.direction,[vx,vy]=state.velocity,[mx,my]=state.movement,[svx,svy]=config.swipe.velocity,[sx,sy]=config.swipe.distance;state.elapsedTime<config.swipe.duration&&(Math.abs(vx)>svx&&Math.abs(mx)>sx&&(state.swipe[0]=dirx),Math.abs(vy)>svy&&Math.abs(my)>sy&&(state.swipe[1]=diry))}this.emit()}}}pointerClick(event){!this.state.tap&&0<event.detail&&
(event.preventDefault(),event.stopPropagation())}setupPointer(event){const config=this.config,device=config.device;try{if("pointer"===device&&void 0===config.preventScrollDelay){const currentTarget="uv"in event?event.sourceEvent.currentTarget:event.currentTarget;"auto"===window.getComputedStyle(currentTarget).touchAction&&console.warn("[@use-gesture]: The drag target has its `touch-action` style property set to `auto`. It is recommended to add `touch-action: 'none'` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\n\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.",
currentTarget)}}catch(_unused2){}config.pointerLock&&event.currentTarget.requestPointerLock();config.pointerCapture||(this.eventStore.add(this.sharedConfig.window,device,"change",this.pointerMove.bind(this)),this.eventStore.add(this.sharedConfig.window,device,"end",this.pointerUp.bind(this)),this.eventStore.add(this.sharedConfig.window,device,"cancel",this.pointerUp.bind(this)))}pointerClean(){this.config.pointerLock&&document.pointerLockElement===this.state.currentTarget&&document.exitPointerLock()}preventScroll(event){this.state._preventScroll&&
event.cancelable&&event.preventDefault()}setupScrollPrevention(event){this.state._preventScroll=!1;"persist"in event&&"function"===typeof event.persist&&event.persist();const remove=this.eventStore.add(this.sharedConfig.window,"touch","change",this.preventScroll.bind(this),{passive:!1});this.eventStore.add(this.sharedConfig.window,"touch","end",remove);this.eventStore.add(this.sharedConfig.window,"touch","cancel",remove);this.timeoutStore.add("startPointerDrag",this.startPointerDrag.bind(this),this.config.preventScrollDelay,
event)}setupDelayTrigger(event){this.state._delayed=!0;this.timeoutStore.add("dragDelay",()=>{this.state._step=[0,0];this.startPointerDrag(event)},this.config.delay)}keyDown(event){const deltaFn=KEYS_DELTA_MAP[event.key];if(deltaFn){const state=this.state,factor=event.shiftKey?10:event.altKey?.1:1;this.start(event);state._delta=deltaFn(factor);state._keyboardActive=!0;maths.V.addTo(state._movement,state._delta);this.compute(event);this.emit()}}keyUp(event){event.key in KEYS_DELTA_MAP&&(this.state._keyboardActive=
!1,this.setActive(),this.compute(event),this.emit())}bind(bindFunction){const device=this.config.device;bindFunction(device,"start",this.pointerDown.bind(this));this.config.pointerCapture&&(bindFunction(device,"change",this.pointerMove.bind(this)),bindFunction(device,"end",this.pointerUp.bind(this)),bindFunction(device,"cancel",this.pointerUp.bind(this)),bindFunction("lostPointerCapture","",this.pointerUp.bind(this)));this.config.keys&&(bindFunction("key","down",this.keyDown.bind(this)),bindFunction("key",
"up",this.keyUp.bind(this)));this.config.filterTaps&&bindFunction("click","",this.pointerClick.bind(this),{capture:!0,passive:!1})}}global="undefined"!==typeof window&&window.document&&window.document.createElement;try{var JSCompiler_inline_result$jscomp$0="constructor"in GestureEvent}catch(e){JSCompiler_inline_result$jscomp$0=!1}const SUPPORT={isBrowser:global,gesture:JSCompiler_inline_result$jscomp$0,touch:global&&"ontouchstart"in window||global&&1<window.navigator.maxTouchPoints,touchscreen:global&&
"ontouchstart"in window||global&&1<window.navigator.maxTouchPoints,pointer:global&&"onpointerdown"in window,pointerLock:global&&"exitPointerLock"in window.document},DEFAULT_DRAG_AXIS_THRESHOLD={mouse:0,touch:0,pen:8};global=_objectSpread2(_objectSpread2({},coordinatesConfigResolver),{},{device(_v,_k,{pointer:{touch=!1,lock=!1,mouse=!1}={}}){this.pointerLock=lock&&SUPPORT.pointerLock;return SUPPORT.touch&&touch?"touch":this.pointerLock?"mouse":SUPPORT.pointer&&!mouse?"pointer":SUPPORT.touch?"touch":
"mouse"},preventScrollAxis(value,_k,{preventScroll}){this.preventScrollDelay="number"===typeof preventScroll?preventScroll:preventScroll||void 0===preventScroll&&value?250:void 0;if(SUPPORT.touchscreen&&!1!==preventScroll)return value?value:void 0!==preventScroll?"y":void 0},pointerCapture(_v,_k,{pointer:{capture=!0,buttons=1,keys=!0}={}}){this.pointerButtons=buttons;this.keys=keys;return!this.pointerLock&&"pointer"===this.device&&capture},threshold(value,_k,{filterTaps=!1,tapsThreshold=3,axis}){value=
maths.V.toVector(value,filterTaps?tapsThreshold:axis?1:0);this.filterTaps=filterTaps;this.tapsThreshold=tapsThreshold;return value},swipe({velocity=.5,distance=50,duration=250}={}){return{velocity:this.transform(maths.V.toVector(velocity)),distance:this.transform(maths.V.toVector(distance)),duration}},delay(value=0){switch(value){case !0:return 180;case !1:return 0;default:return value}},axisThreshold(value){return value?_objectSpread2(_objectSpread2({},DEFAULT_DRAG_AXIS_THRESHOLD),value):DEFAULT_DRAG_AXIS_THRESHOLD}});
Object.assign(global,{useTouch(value){if(void 0!==value)throw Error("[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.");return NaN},experimental_preventWindowScrollY(value){if(void 0!==value)throw Error("[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.");return NaN},swipeVelocity(value){if(void 0!==value)throw Error("[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.");
return NaN},swipeDistance(value){if(void 0!==value)throw Error("[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.");return NaN},swipeDuration(value){if(void 0!==value)throw Error("[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.");return NaN}});class PinchEngine extends Engine{constructor(...args){super(...args);_defineProperty(this,"ingKey","pinching");_defineProperty(this,
"aliasKey","da")}init(){this.state.offset=[1,0];this.state.lastOffset=[1,0];this.state._pointerEvents=new Map}reset(){super.reset();const state=this.state;state._touchIds=[];state.canceled=!1;state.cancel=this.cancel.bind(this);state.turns=0}computeOffset(){const {type,movement,lastOffset}=this.state;this.state.offset="wheel"===type?maths.V.add(movement,lastOffset):[(1+movement[0])*lastOffset[0],movement[1]+lastOffset[1]]}computeMovement(){const {offset,lastOffset}=this.state;this.state.movement=
[offset[0]/lastOffset[0],offset[1]-lastOffset[1]]}axisIntent(){const state=this.state,[_m0,_m1]=state._movement;if(!state.axis){const axisMovementDifference=30*Math.abs(_m0)-Math.abs(_m1);0>axisMovementDifference?state.axis="angle":0<axisMovementDifference&&(state.axis="scale")}}restrictToAxis(v){this.config.lockDirection&&("scale"===this.state.axis?v[1]=0:"angle"===this.state.axis&&(v[0]=0))}cancel(){const state=this.state;state.canceled||setTimeout(()=>{state.canceled=!0;state._active=!1;this.compute();
this.emit()},0)}touchStart(event){this.ctrl.setEventIds(event);var state=this.state;const ctrlTouchIds=this.ctrl.touchIds;state._active&&state._touchIds.every(id=>ctrlTouchIds.has(id))||2>ctrlTouchIds.size||(this.start(event),state._touchIds=Array.from(ctrlTouchIds).slice(0,2),state=touchDistanceAngle(event,state._touchIds),this.pinchStart(event,state))}pointerStart(event){if(null==event.buttons||1===event.buttons%2){this.ctrl.setEventIds(event);event.target.setPointerCapture(event.pointerId);var state=
this.state,_pointerEvents=state._pointerEvents,ctrlPointerIds=this.ctrl.pointerIds;state._active&&Array.from(_pointerEvents.keys()).every(id=>ctrlPointerIds.has(id))||(2>_pointerEvents.size&&_pointerEvents.set(event.pointerId,event),2>state._pointerEvents.size||(this.start(event),state=distanceAngle(...Array.from(_pointerEvents.values())),this.pinchStart(event,state)))}}pinchStart(event,payload){this.state.origin=payload.origin;this.computeValues([payload.distance,payload.angle]);this.computeInitial();
this.compute(event);this.emit()}touchMove(event){if(this.state._active){var payload=touchDistanceAngle(event,this.state._touchIds);this.pinchMove(event,payload)}}pointerMove(event){var _pointerEvents=this.state._pointerEvents;_pointerEvents.has(event.pointerId)&&_pointerEvents.set(event.pointerId,event);this.state._active&&(_pointerEvents=distanceAngle(...Array.from(_pointerEvents.values())),this.pinchMove(event,_pointerEvents))}pinchMove(event,payload){const state=this.state,delta_a=payload.angle-
state._values[1];let delta_turns=0;270<Math.abs(delta_a)&&(delta_turns+=Math.sign(delta_a));this.computeValues([payload.distance,payload.angle-360*delta_turns]);state.origin=payload.origin;state.turns=delta_turns;state._movement=[state._values[0]/state._initial[0]-1,state._values[1]-state._initial[1]];this.compute(event);this.emit()}touchEnd(event){this.ctrl.setEventIds(event);this.state._active&&this.state._touchIds.some(id=>!this.ctrl.touchIds.has(id))&&(this.state._active=!1,this.compute(event),
this.emit())}pointerEnd(event){const state=this.state;this.ctrl.setEventIds(event);try{event.target.releasePointerCapture(event.pointerId)}catch(_unused){}state._pointerEvents.has(event.pointerId)&&state._pointerEvents.delete(event.pointerId);state._active&&2>state._pointerEvents.size&&(state._active=!1,this.compute(event),this.emit())}gestureStart(event){event.cancelable&&event.preventDefault();const state=this.state;state._active||(this.start(event),this.computeValues([event.scale,event.rotation]),
state.origin=[event.clientX,event.clientY],this.compute(event),this.emit())}gestureMove(event){event.cancelable&&event.preventDefault();if(this.state._active){var state=this.state;this.computeValues([event.scale,event.rotation]);state.origin=[event.clientX,event.clientY];var _previousMovement=state._movement;state._movement=[event.scale-1,event.rotation];state._delta=maths.V.sub(state._movement,_previousMovement);this.compute(event);this.emit()}}gestureEnd(event){this.state._active&&(this.state._active=
!1,this.compute(event),this.emit())}wheel(event){const modifierKey=this.config.modifierKey;if(!modifierKey||event[modifierKey])this.state._active?this.wheelChange(event):this.wheelStart(event),this.timeoutStore.add("wheelEnd",this.wheelEnd.bind(this))}wheelStart(event){this.start(event);this.wheelChange(event)}wheelChange(event){"uv"in event||(event.cancelable&&event.preventDefault(),event.defaultPrevented||console.warn("[@use-gesture]: To properly support zoom on trackpads, try using the `target` option.\n\nThis message will only appear in development mode."));
const state=this.state;state._delta=[-wheelValues(event)[1]/100*state.offset[0],0];maths.V.addTo(state._movement,state._delta);clampStateInternalMovementToBounds(state);this.state.origin=[event.clientX,event.clientY];this.compute(event);this.emit()}wheelEnd(){this.state._active&&(this.state._active=!1,this.compute(),this.emit())}bind(bindFunction){const device=this.config.device;device&&(bindFunction(device,"start",this[device+"Start"].bind(this)),bindFunction(device,"change",this[device+"Move"].bind(this)),
bindFunction(device,"end",this[device+"End"].bind(this)),bindFunction(device,"cancel",this[device+"End"].bind(this)));this.config.pinchOnWheel&&bindFunction("wheel","",this.wheel.bind(this),{passive:!1})}}var pinchConfigResolver=_objectSpread2(_objectSpread2({},require),{},{device(_v,_k,{shared,pointer:{touch=!1}={}}){if(shared.target&&!SUPPORT.touch&&SUPPORT.gesture)return"gesture";if(SUPPORT.touch&&touch)return"touch";if(SUPPORT.touchscreen){if(SUPPORT.pointer)return"pointer";if(SUPPORT.touch)return"touch"}},
bounds(_v,_k,{scaleBounds={},angleBounds={}}){const _scaleBounds=state=>{state=call(scaleBounds,state);state=Object.assign({},{min:-Infinity,max:Infinity},state||{});return[state.min,state.max]},_angleBounds=state=>{state=call(angleBounds,state);state=Object.assign({},{min:-Infinity,max:Infinity},state||{});return[state.min,state.max]};return"function"!==typeof scaleBounds&&"function"!==typeof angleBounds?[_scaleBounds(),_angleBounds()]:state=>[_scaleBounds(state),_angleBounds(state)]},threshold(value,
_k,config){this.lockDirection="lock"===config.axis;return maths.V.toVector(value,this.lockDirection?[.1,3]:0)},modifierKey(value){return void 0===value?"ctrlKey":value},pinchOnWheel(value=!0){return value}});class MoveEngine extends CoordinatesEngine{constructor(...args){super(...args);_defineProperty(this,"ingKey","moving")}move(event){this.config.mouseOnly&&"mouse"!==event.pointerType||(this.state._active?this.moveChange(event):this.moveStart(event),this.timeoutStore.add("moveEnd",this.moveEnd.bind(this)))}moveStart(event){this.start(event);
this.computeValues(pointerValues(event));this.compute(event);this.computeInitial();this.emit()}moveChange(event){if(this.state._active){var values=pointerValues(event),state=this.state;state._delta=maths.V.sub(values,state._values);maths.V.addTo(state._movement,state._delta);this.computeValues(values);this.compute(event);this.emit()}}moveEnd(event){this.state._active&&(this.state._active=!1,this.compute(event),this.emit())}bind(bindFunction){bindFunction("pointer","change",this.move.bind(this));bindFunction("pointer",
"leave",this.moveEnd.bind(this))}}var moveConfigResolver=_objectSpread2(_objectSpread2({},coordinatesConfigResolver),{},{mouseOnly:(value=!0)=>value});class ScrollEngine extends CoordinatesEngine{constructor(...args){super(...args);_defineProperty(this,"ingKey","scrolling")}scroll(event){this.state._active||this.start(event);this.scrollChange(event);this.timeoutStore.add("scrollEnd",this.scrollEnd.bind(this))}scrollChange(event){event.cancelable&&event.preventDefault();const state=this.state;var _ref,
_ref2;const {scrollX,scrollY,scrollLeft,scrollTop}=event.currentTarget;var JSCompiler_inline_result=[null!==(_ref=null!==scrollX&&void 0!==scrollX?scrollX:scrollLeft)&&void 0!==_ref?_ref:0,null!==(_ref2=null!==scrollY&&void 0!==scrollY?scrollY:scrollTop)&&void 0!==_ref2?_ref2:0];state._delta=maths.V.sub(JSCompiler_inline_result,state._values);maths.V.addTo(state._movement,state._delta);this.computeValues(JSCompiler_inline_result);this.compute(event);this.emit()}scrollEnd(){this.state._active&&(this.state._active=
!1,this.compute(),this.emit())}bind(bindFunction){bindFunction("scroll","",this.scroll.bind(this))}}require=coordinatesConfigResolver;class WheelEngine extends CoordinatesEngine{constructor(...args){super(...args);_defineProperty(this,"ingKey","wheeling")}wheel(event){this.state._active||this.start(event);this.wheelChange(event);this.timeoutStore.add("wheelEnd",this.wheelEnd.bind(this))}wheelChange(event){const state=this.state;state._delta=wheelValues(event);maths.V.addTo(state._movement,state._delta);
clampStateInternalMovementToBounds(state);this.compute(event);this.emit()}wheelEnd(){this.state._active&&(this.state._active=!1,this.compute(),this.emit())}bind(bindFunction){bindFunction("wheel","",this.wheel.bind(this))}}JSCompiler_inline_result$jscomp$0=coordinatesConfigResolver;class HoverEngine extends CoordinatesEngine{constructor(...args){super(...args);_defineProperty(this,"ingKey","hovering")}enter(event){this.config.mouseOnly&&"mouse"!==event.pointerType||(this.start(event),this.computeValues(pointerValues(event)),
this.compute(event),this.emit())}leave(event){if(!this.config.mouseOnly||"mouse"===event.pointerType){var state=this.state;if(state._active){state._active=!1;var values=pointerValues(event);state._movement=state._delta=maths.V.sub(values,state._values);this.computeValues(values);this.compute(event);state.delta=state.movement;this.emit()}}}bind(bindFunction){bindFunction("pointer","enter",this.enter.bind(this));bindFunction("pointer","leave",this.leave.bind(this))}}module=_objectSpread2(_objectSpread2({},
coordinatesConfigResolver),{},{mouseOnly:(value=!0)=>value});const EngineMap=new Map,ConfigResolverMap=new Map;global={key:"drag",engine:DragEngine,resolver:global};module={key:"hover",engine:HoverEngine,resolver:module};moveConfigResolver={key:"move",engine:MoveEngine,resolver:moveConfigResolver};pinchConfigResolver={key:"pinch",engine:PinchEngine,resolver:pinchConfigResolver};require={key:"scroll",engine:ScrollEngine,resolver:require};JSCompiler_inline_result$jscomp$0={key:"wheel",engine:WheelEngine,
resolver:JSCompiler_inline_result$jscomp$0};exports.ConfigResolverMap=ConfigResolverMap;exports.EngineMap=EngineMap;exports.SUPPORT=SUPPORT;exports._defineProperty=_defineProperty;exports._objectSpread2=_objectSpread2;exports.chain=function(...fns){return 0===fns.length?noop:1===fns.length?fns[0]:function(){let result;for(const fn of fns)result=fn.apply(this,arguments)||result;return result}};exports.dragAction=global;exports.hoverAction=module;exports.isTouch=isTouch;exports.moveAction=moveConfigResolver;
exports.parseProp=function(prop){prop=prop.substring(2).toLowerCase();const passive=!!~prop.indexOf("passive");passive&&(prop=prop.replace("passive",""));var captureKey=pointerCaptureEvents.includes(prop)?"capturecapture":"capture";(captureKey=!!~prop.indexOf(captureKey))&&(prop=prop.replace("capture",""));return{device:prop,capture:captureKey,passive}};exports.pinchAction=pinchConfigResolver;exports.registerAction=function(action){EngineMap.set(action.key,action.engine);ConfigResolverMap.set(action.key,
action.resolver)};exports.scrollAction=require;exports.toDomEventType=function(device,action=""){const deviceProps=EVENT_TYPE_MAP[device];return device+(deviceProps?deviceProps[action]||action:action)};exports.toHandlerProp=function(device,action="",capture=!1){const deviceProps=EVENT_TYPE_MAP[device];action=deviceProps?deviceProps[action]||action:action;return"on"+capitalize(device)+capitalize(action)+(hasCapture(capture,action)?"Capture":"")};exports.touchIds=function(event){return getCurrentTargetTouchList(event).map(touch=>
touch.identifier)};exports.wheelAction=JSCompiler_inline_result$jscomp$0}
//# sourceMappingURL=module$node_modules$$use_gesture$core$dist$actions_f42925e5_cjs_dev.js.map
