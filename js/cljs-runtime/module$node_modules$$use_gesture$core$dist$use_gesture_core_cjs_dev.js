import "./cljs_env.js";
shadow$provide.module$node_modules$$use_gesture$core$dist$use_gesture_core_cjs_dev=function(global,require,module,exports){function resolveWith(config={},resolvers){const result={};for(const [key,resolver]of Object.entries(resolvers))switch(typeof resolver){case "function":resolvers=resolver.call(result,config[key],key,config);Number.isNaN(resolvers)||(result[key]=resolvers);break;case "object":result[key]=resolveWith(config[key],resolver);break;case "boolean":resolver&&(result[key]=config[key])}return result}
function parse(newConfig,gestureKey,_config={}){const {target,eventOptions,window,enabled,transform}=newConfig;var excluded=_excluded;if(null==newConfig)newConfig={};else{if(null==newConfig)var target$jscomp$0={};else{target$jscomp$0={};var sourceKeys=Object.keys(newConfig),i;for(i=0;i<sourceKeys.length;i++){var key=sourceKeys[i];0<=excluded.indexOf(key)||(target$jscomp$0[key]=newConfig[key])}}if(Object.getOwnPropertySymbols)for(i=Object.getOwnPropertySymbols(newConfig),key=0;key<i.length;key++)sourceKeys=
i[key],0<=excluded.indexOf(sourceKeys)||Object.prototype.propertyIsEnumerable.call(newConfig,sourceKeys)&&(target$jscomp$0[sourceKeys]=newConfig[sourceKeys]);newConfig=target$jscomp$0}_config.shared=resolveWith({target,eventOptions,window,enabled,transform},sharedConfigResolver);if(gestureKey){var resolver=actions_dist_useGestureCoreActions.ConfigResolverMap.get(gestureKey);_config[gestureKey]=resolveWith(actions_dist_useGestureCoreActions._objectSpread2({shared:_config.shared},newConfig),resolver)}else for(resolver in newConfig)if(gestureKey=
actions_dist_useGestureCoreActions.ConfigResolverMap.get(resolver))_config[resolver]=resolveWith(actions_dist_useGestureCoreActions._objectSpread2({shared:_config.shared},newConfig[resolver]),gestureKey);else if(!"drag pinch scroll wheel move hover".split(" ").includes(resolver)){if("domTarget"===resolver)throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");console.warn(`[@use-gesture]: Unknown config key \`${resolver}\` was used. Please read the documentation for further information.`)}return _config}
function setupGesture(ctrl,gestureKey){ctrl.gestures.add(gestureKey);ctrl.gestureEventStores[gestureKey]=new EventStore(ctrl,gestureKey);ctrl.gestureTimeoutStores[gestureKey]=new TimeoutStore}function registerGesture(actions,handlers,handlerKey,key,internalHandlers,config){if(actions.has(handlerKey))if(actions_dist_useGestureCoreActions.EngineMap.has(key)){var startKey=handlerKey+"Start",endKey=handlerKey+"End";internalHandlers[key]=state=>{let memo=void 0;if(state.first&&startKey in handlers)handlers[startKey](state);
handlerKey in handlers&&(memo=handlers[handlerKey](state));if(state.last&&endKey in handlers)handlers[endKey](state);return memo};config[key]=config[key]||{}}else console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${key}\` gesture but isn't properly configured.\n\nPlease add \`${key}Action\` when creating your handler.`)}Object.defineProperty(exports,"__esModule",{value:!0});var actions_dist_useGestureCoreActions=require("module$node_modules$$use_gesture$core$dist$actions_f42925e5_cjs_dev");
require("module$node_modules$$use_gesture$core$dist$maths_0c237923_cjs_dev");const sharedConfigResolver={target(value){if(value)return()=>"current"in value?value.current:value},enabled(value=!0){return value},window(value=actions_dist_useGestureCoreActions.SUPPORT.isBrowser?window:void 0){return value},eventOptions({passive=!0,capture=!1}={}){return{passive,capture}},transform(value){return value}},_excluded=["target","eventOptions","window","enabled","transform"];class EventStore{constructor(ctrl,
gestureKey){actions_dist_useGestureCoreActions._defineProperty(this,"_listeners",new Set);this._ctrl=ctrl;this._gestureKey=gestureKey}add(element,device,action,handler,options){const listeners=this._listeners,type=actions_dist_useGestureCoreActions.toDomEventType(device,action),eventOptions=actions_dist_useGestureCoreActions._objectSpread2(actions_dist_useGestureCoreActions._objectSpread2({},this._gestureKey?this._ctrl.config[this._gestureKey].eventOptions:{}),options);element.addEventListener(type,
handler,eventOptions);const remove=()=>{element.removeEventListener(type,handler,eventOptions);listeners.delete(remove)};listeners.add(remove);return remove}clean(){this._listeners.forEach(remove=>remove());this._listeners.clear()}}class TimeoutStore{constructor(){actions_dist_useGestureCoreActions._defineProperty(this,"_timeouts",new Map)}add(key,callback,ms=140,...args){this.remove(key);this._timeouts.set(key,window.setTimeout(callback,ms,...args))}remove(key){(key=this._timeouts.get(key))&&window.clearTimeout(key)}clean(){this._timeouts.forEach(timeout=>
void window.clearTimeout(timeout));this._timeouts.clear()}}class Controller{constructor(handlers){actions_dist_useGestureCoreActions._defineProperty(this,"gestures",new Set);actions_dist_useGestureCoreActions._defineProperty(this,"_targetEventStore",new EventStore(this));actions_dist_useGestureCoreActions._defineProperty(this,"gestureEventStores",{});actions_dist_useGestureCoreActions._defineProperty(this,"gestureTimeoutStores",{});actions_dist_useGestureCoreActions._defineProperty(this,"handlers",
{});actions_dist_useGestureCoreActions._defineProperty(this,"config",{});actions_dist_useGestureCoreActions._defineProperty(this,"pointerIds",new Set);actions_dist_useGestureCoreActions._defineProperty(this,"touchIds",new Set);actions_dist_useGestureCoreActions._defineProperty(this,"state",{shared:{shiftKey:!1,metaKey:!1,ctrlKey:!1,altKey:!1}});handlers.drag&&setupGesture(this,"drag");handlers.wheel&&setupGesture(this,"wheel");handlers.scroll&&setupGesture(this,"scroll");handlers.move&&setupGesture(this,
"move");handlers.pinch&&setupGesture(this,"pinch");handlers.hover&&setupGesture(this,"hover")}setEventIds(event){if(actions_dist_useGestureCoreActions.isTouch(event))return this.touchIds=new Set(actions_dist_useGestureCoreActions.touchIds(event));if("pointerId"in event)return"pointerup"===event.type||"pointercancel"===event.type?this.pointerIds.delete(event.pointerId):"pointerdown"===event.type&&this.pointerIds.add(event.pointerId),this.pointerIds}applyHandlers(handlers,nativeHandlers){this.handlers=
handlers;this.nativeHandlers=nativeHandlers}applyConfig(config,gestureKey){this.config=parse(config,gestureKey,this.config)}clean(){this._targetEventStore.clean();for(const key of this.gestures)this.gestureEventStores[key].clean(),this.gestureTimeoutStores[key].clean()}effect(){this.config.shared.target&&this.bind();return()=>this._targetEventStore.clean()}bind(...args){var sharedConfig=this.config.shared;const props={};let target;if(sharedConfig.target&&(target=sharedConfig.target(),!target))return;
if(sharedConfig.enabled){for(const gestureKey of this.gestures){const gestureConfig=this.config[gestureKey],bindFunction=bindToProps(props,gestureConfig.eventOptions,!!target);gestureConfig.enabled&&(new (actions_dist_useGestureCoreActions.EngineMap.get(gestureKey))(this,args,gestureKey)).bind(bindFunction)}sharedConfig=bindToProps(props,sharedConfig.eventOptions,!!target);for(const eventKey in this.nativeHandlers)sharedConfig(eventKey,"",event=>this.nativeHandlers[eventKey](actions_dist_useGestureCoreActions._objectSpread2(actions_dist_useGestureCoreActions._objectSpread2({},
this.state.shared),{},{event,args})),void 0,!0)}for(const handlerProp in props)props[handlerProp]=actions_dist_useGestureCoreActions.chain(...props[handlerProp]);if(!target)return props;for(const handlerProp in props){const {device,capture,passive}=actions_dist_useGestureCoreActions.parseProp(handlerProp);this._targetEventStore.add(target,device,"",props[handlerProp],{capture,passive})}}}const bindToProps=(props,eventOptions,withPassiveOption)=>(device,action,handler,options={},isNative=!1)=>{var _options$capture,
_options$passive;const capture=null!==(_options$capture=options.capture)&&void 0!==_options$capture?_options$capture:eventOptions.capture;options=null!==(_options$passive=options.passive)&&void 0!==_options$passive?_options$passive:eventOptions.passive;device=isNative?device:actions_dist_useGestureCoreActions.toHandlerProp(device,action,capture);withPassiveOption&&options&&(device+="Passive");props[device]=props[device]||[];props[device].push(handler)},RE_NOT_NATIVE=/^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
exports.Controller=Controller;exports.parseMergedHandlers=function(mergedHandlers,mergedConfig){const native={},handlers={},actions=new Set;for(let key in mergedHandlers)RE_NOT_NATIVE.test(key)?(actions.add(RegExp.lastMatch),handlers[key]=mergedHandlers[key]):native[key]=mergedHandlers[key];const [handlers$jscomp$0,nativeHandlers,actions$jscomp$0]=[handlers,native,actions];mergedHandlers={};registerGesture(actions$jscomp$0,handlers$jscomp$0,"onDrag","drag",mergedHandlers,mergedConfig);registerGesture(actions$jscomp$0,
handlers$jscomp$0,"onWheel","wheel",mergedHandlers,mergedConfig);registerGesture(actions$jscomp$0,handlers$jscomp$0,"onScroll","scroll",mergedHandlers,mergedConfig);registerGesture(actions$jscomp$0,handlers$jscomp$0,"onPinch","pinch",mergedHandlers,mergedConfig);registerGesture(actions$jscomp$0,handlers$jscomp$0,"onMove","move",mergedHandlers,mergedConfig);registerGesture(actions$jscomp$0,handlers$jscomp$0,"onHover","hover",mergedHandlers,mergedConfig);return{handlers:mergedHandlers,config:mergedConfig,
nativeHandlers}}}
//# sourceMappingURL=module$node_modules$$use_gesture$core$dist$use_gesture_core_cjs_dev.js.map
