import "./cljs_env.js";
shadow$provide.module$node_modules$framer_motion$dist$cjs$index=function(global,require,module,exports){function _interopDefaultLegacy(e){return e&&"object"===typeof e&&"default"in e?e:{"default":e}}function useVisualElementContext(){return React.useContext(MotionContext).visualElement}function useVisualElement(Component,visualState,props,createVisualElement){const parent=useVisualElementContext(),lazyContext=React.useContext(LazyContext),presenceContext=React.useContext(PresenceContext),reducedMotionConfig=
React.useContext(MotionConfigContext).reducedMotion,visualElementRef=React.useRef();createVisualElement=createVisualElement||lazyContext.renderer;!visualElementRef.current&&createVisualElement&&(visualElementRef.current=createVisualElement(Component,{visualState,parent,props,presenceId:presenceContext?presenceContext.id:void 0,blockInitialAnimation:presenceContext?!1===presenceContext.initial:!1,reducedMotionConfig}));const visualElement=visualElementRef.current;useIsomorphicLayoutEffect(()=>{visualElement&&
visualElement.render()});React.useEffect(()=>{visualElement&&visualElement.animationState&&visualElement.animationState.animateChanges()});useIsomorphicLayoutEffect(()=>()=>visualElement&&visualElement.notify("Unmount"),[]);return visualElement}function isRefObject(ref){return"object"===typeof ref&&Object.prototype.hasOwnProperty.call(ref,"current")}function useMotionRef(visualState,visualElement,externalRef){return React.useCallback(instance=>{instance&&visualState.mount&&visualState.mount(instance);
visualElement&&(instance?visualElement.mount(instance):visualElement.unmount());externalRef&&("function"===typeof externalRef?externalRef(instance):isRefObject(externalRef)&&(externalRef.current=instance))},[visualElement])}function isVariantLabel(v){return"string"===typeof v||Array.isArray(v)}function isAnimationControls(v){return"object"===typeof v&&"function"===typeof v.start}function isControllingVariants(props){return isAnimationControls(props.animate)||variantProps$1.some(name=>isVariantLabel(props[name]))}
function isVariantNode(props){return!(!isControllingVariants(props)&&!props.variants)}function getCurrentTreeVariants(props,context){if(isControllingVariants(props)){const {initial,animate}=props;return{initial:!1===initial||isVariantLabel(initial)?initial:void 0,animate:isVariantLabel(animate)?animate:void 0}}return!1!==props.inherit?context:{}}function useCreateMotionContext(props){const {initial,animate}=getCurrentTreeVariants(props,React.useContext(MotionContext));return React.useMemo(()=>({initial,
animate}),[variantLabelsAsDependency(initial),variantLabelsAsDependency(animate)])}function variantLabelsAsDependency(prop){return Array.isArray(prop)?prop.join(" "):prop}function loadFeatures(features){for(const key in features)"projectionNodeConstructor"===key?featureDefinitions.projectionNodeConstructor=features[key]:featureDefinitions[key].Component=features[key]}function useConstant(init){const ref=React.useRef(null);null===ref.current&&(ref.current=init());return ref.current}function useProjectionId(){return useConstant(()=>
{if(globalProjectionState.hasEverUpdated)return id$2++})}function createMotionComponent($jscomp$destructuring$var0){var {preloadedFeatures,createVisualElement,projectionNodeConstructor,useRender,useVisualState,Component}=$jscomp$destructuring$var0;preloadedFeatures&&loadFeatures(preloadedFeatures);$jscomp$destructuring$var0=React.forwardRef(function(props,externalRef){var JSCompiler_temp_const=Object,JSCompiler_temp_const$jscomp$0=JSCompiler_temp_const.assign,JSCompiler_temp_const$jscomp$1=React.useContext(MotionConfigContext),
{layoutId}=props,layoutGroupId=React.useContext(LayoutGroupContext).id;JSCompiler_temp_const=JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,{},JSCompiler_temp_const$jscomp$1,props,{layoutId:layoutGroupId&&void 0!==layoutId?layoutGroupId+"-"+layoutId:layoutId});({isStatic:JSCompiler_temp_const$jscomp$0}=JSCompiler_temp_const);JSCompiler_temp_const$jscomp$1=null;layoutId=useCreateMotionContext(props);layoutGroupId=JSCompiler_temp_const$jscomp$0?void 0:useProjectionId();const visualState=
useVisualState(props,JSCompiler_temp_const$jscomp$0);if(!JSCompiler_temp_const$jscomp$0&&isBrowser){layoutId.visualElement=useVisualElement(Component,visualState,JSCompiler_temp_const,createVisualElement);const lazyStrictMode=React.useContext(LazyContext).strict,initialLayoutGroupConfig=React.useContext(SwitchLayoutGroupContext);layoutId.visualElement&&(JSCompiler_temp_const$jscomp$1=layoutId.visualElement.loadFeatures(JSCompiler_temp_const,lazyStrictMode,preloadedFeatures,layoutGroupId,projectionNodeConstructor||
featureDefinitions.projectionNodeConstructor,initialLayoutGroupConfig))}return React__namespace.createElement(VisualElementHandler,{visualElement:layoutId.visualElement,props:JSCompiler_temp_const},JSCompiler_temp_const$jscomp$1,React__namespace.createElement(MotionContext.Provider,{value:layoutId},useRender(Component,props,layoutGroupId,useMotionRef(visualState,layoutId.visualElement,externalRef),visualState,JSCompiler_temp_const$jscomp$0,layoutId.visualElement)))});$jscomp$destructuring$var0[motionComponentSymbol]=
Component;return $jscomp$destructuring$var0}function createMotionProxy(createConfig){function custom(Component,customMotionComponentConfig){customMotionComponentConfig=void 0===customMotionComponentConfig?{}:customMotionComponentConfig;return createMotionComponent(createConfig(Component,customMotionComponentConfig))}if("undefined"===typeof Proxy)return custom;const componentCache=new Map;return new Proxy(custom,{get:(_target,key)=>{componentCache.has(key)||componentCache.set(key,custom(key));return componentCache.get(key)}})}
function isSVGComponent(Component){return"string"===typeof Component&&!Component.includes("-")&&(-1<lowercaseSVGElements.indexOf(Component)||/[A-Z]/.test(Component))?!0:!1}function addScaleCorrector(correctors){Object.assign(scaleCorrectors,correctors)}function isForcedMotionValue(key,$jscomp$destructuring$var2){var {layout,layoutId}=$jscomp$destructuring$var2;return transformProps.has(key)||key.startsWith("origin")||(layout||void 0!==layoutId)&&(!!scaleCorrectors[key]||"opacity"===key)}function buildTransform($jscomp$destructuring$var3,
$jscomp$destructuring$var4,transformIsDefault,transformTemplate){var {transform,transformKeys}=$jscomp$destructuring$var3,{enableHardwareAcceleration=!0,allowTransformNone=!0}=$jscomp$destructuring$var4;$jscomp$destructuring$var3="";transformKeys.sort(sortTransformProps);for(const key of transformKeys)$jscomp$destructuring$var3+=`${translateAlias[key]||key}(${transform[key]}) `;enableHardwareAcceleration&&!transform.z&&($jscomp$destructuring$var3+="translateZ(0)");$jscomp$destructuring$var3=$jscomp$destructuring$var3.trim();
transformTemplate?$jscomp$destructuring$var3=transformTemplate(transform,transformIsDefault?"":$jscomp$destructuring$var3):allowTransformNone&&transformIsDefault&&($jscomp$destructuring$var3="none");return $jscomp$destructuring$var3}function buildHTMLStyles(state,latestValues,options,transformTemplate){const {style,vars,transform,transformKeys,transformOrigin}=state;transformKeys.length=0;let hasTransform=!1,hasTransformOrigin=!1,transformIsNone=!0;for(const key in latestValues){const value=latestValues[key];
if(key.startsWith("--")){vars[key]=value;continue}const valueType=numberValueTypes[key];var value$jscomp$0=value;value$jscomp$0=valueType&&"number"===typeof value$jscomp$0?valueType.transform(value$jscomp$0):value$jscomp$0;transformProps.has(key)?(hasTransform=!0,transform[key]=value$jscomp$0,transformKeys.push(key),transformIsNone&&value!==(valueType.default||0)&&(transformIsNone=!1)):key.startsWith("origin")?(hasTransformOrigin=!0,transformOrigin[key]=value$jscomp$0):style[key]=value$jscomp$0}latestValues.transform||
(hasTransform||transformTemplate?style.transform=buildTransform(state,options,transformIsNone,transformTemplate):style.transform&&(style.transform="none"));if(hasTransformOrigin){const {originX="50%",originY="50%",originZ=0}=transformOrigin;style.transformOrigin=`${originX} ${originY} ${originZ}`}}function copyRawValuesOnly(target,source,props){for(const key in source)isMotionValue(source[key])||isForcedMotionValue(key,props)||(target[key]=source[key])}function useInitialMotionValues($jscomp$destructuring$var5,
visualState,isStatic){var {transformTemplate}=$jscomp$destructuring$var5;return React.useMemo(()=>{const state=createHtmlRenderState();buildHTMLStyles(state,visualState,{enableHardwareAcceleration:!isStatic},transformTemplate);return Object.assign({},state.vars,state.style)},[visualState])}function useHTMLProps(props,visualState,isStatic){const htmlProps={},style={};copyRawValuesOnly(style,props.style||{},props);Object.assign(style,useInitialMotionValues(props,visualState,isStatic));visualState=props.transformValues?
props.transformValues(style):style;props.drag&&!1!==props.dragListener&&(htmlProps.draggable=!1,visualState.userSelect=visualState.WebkitUserSelect=visualState.WebkitTouchCallout="none",visualState.touchAction=!0===props.drag?"none":`pan-${"x"===props.drag?"y":"x"}`);htmlProps.style=visualState;return htmlProps}function isValidMotionProp(key){return validMotionProps.has(key)}function loadExternalIsValidProp(isValidProp){isValidProp&&(shouldForward=key=>key.startsWith("on")?!isValidMotionProp(key):
isValidProp(key))}function filterProps(props,isDom,forwardMotionProps){const filteredProps={};for(const key in props)if(shouldForward(key)||!0===forwardMotionProps&&isValidMotionProp(key)||!isDom&&!isValidMotionProp(key)||props.draggable&&key.startsWith("onDrag"))filteredProps[key]=props[key];return filteredProps}function calcOrigin$1(origin,offset,size){return"string"===typeof origin?origin:styleValueTypes.px.transform(offset+size*origin)}function buildSVGAttrs(state,$jscomp$destructuring$var6,options,
isSVGTag,transformTemplate){var $jscomp$destructuring$var8=Object.assign({},$jscomp$destructuring$var6),attrX=$jscomp$destructuring$var6.attrX,attrY=$jscomp$destructuring$var6.attrY,originX=$jscomp$destructuring$var6.originX,originY=$jscomp$destructuring$var6.originY,pathLength=$jscomp$destructuring$var6.pathLength,pathSpacing=void 0===$jscomp$destructuring$var6.pathSpacing?1:$jscomp$destructuring$var6.pathSpacing;$jscomp$destructuring$var6=void 0===$jscomp$destructuring$var6.pathOffset?0:$jscomp$destructuring$var6.pathOffset;
$jscomp$destructuring$var8=(delete $jscomp$destructuring$var8.attrX,delete $jscomp$destructuring$var8.attrY,delete $jscomp$destructuring$var8.originX,delete $jscomp$destructuring$var8.originY,delete $jscomp$destructuring$var8.pathLength,delete $jscomp$destructuring$var8.pathSpacing,delete $jscomp$destructuring$var8.pathOffset,$jscomp$destructuring$var8);buildHTMLStyles(state,$jscomp$destructuring$var8,options,transformTemplate);if(isSVGTag)state.style.viewBox&&(state.attrs.viewBox=state.style.viewBox);
else{state.attrs=state.style;state.style={};var {attrs,style,dimensions}=state;attrs.transform&&(dimensions&&(style.transform=attrs.transform),delete attrs.transform);dimensions&&(void 0!==originX||void 0!==originY||style.transform)&&(state=void 0!==originY?originY:.5,originX=calcOrigin$1(void 0!==originX?originX:.5,dimensions.x,dimensions.width),state=calcOrigin$1(state,dimensions.y,dimensions.height),style.transformOrigin=`${originX} ${state}`);void 0!==attrX&&(attrs.x=attrX);void 0!==attrY&&(attrs.y=
attrY);void 0!==pathLength&&(attrY=pathSpacing,attrY=void 0===attrY?1:attrY,attrs.pathLength=1,attrX=camelKeys,attrs[attrX.offset]=styleValueTypes.px.transform(-(void 0===$jscomp$destructuring$var6?0:$jscomp$destructuring$var6)),pathLength=styleValueTypes.px.transform(pathLength),$jscomp$destructuring$var6=styleValueTypes.px.transform(attrY),attrs[attrX.array]=`${pathLength} ${$jscomp$destructuring$var6}`)}}function useSVGProps(props,visualState,_isStatic,Component){_isStatic=React.useMemo(()=>{const state=
createSvgRenderState();buildSVGAttrs(state,visualState,{enableHardwareAcceleration:!1},isSVGTag(Component),props.transformTemplate);return Object.assign({},state.attrs,{style:Object.assign({},state.style)})},[visualState]);if(props.style){const rawStyles={};copyRawValuesOnly(rawStyles,props.style,props);_isStatic.style=Object.assign({},rawStyles,_isStatic.style)}return _isStatic}function createUseRender(forwardMotionProps){forwardMotionProps=void 0===forwardMotionProps?!1:forwardMotionProps;return(Component,
props,projectionId,ref,$jscomp$destructuring$var9,isStatic)=>{({latestValues:$jscomp$destructuring$var9}=$jscomp$destructuring$var9);isStatic=(isSVGComponent(Component)?useSVGProps:useHTMLProps)(props,$jscomp$destructuring$var9,isStatic,Component);props=filterProps(props,"string"===typeof Component,forwardMotionProps);ref=Object.assign({},props,isStatic,{ref});projectionId&&(ref["data-projection-id"]=projectionId);return React.createElement(Component,ref)}}function renderHTML(element,$jscomp$destructuring$var10,
styleProp,projection){var {style,vars}=$jscomp$destructuring$var10;Object.assign(element.style,style,projection&&projection.getProjectionStyles(styleProp));for(const key in vars)element.style.setProperty(key,vars[key])}function renderSVG(element,renderState,_styleProp,projection){renderHTML(element,renderState,void 0,projection);for(const key in renderState.attrs)element.setAttribute(camelCaseAttributes.has(key)?key:camelToDash(key),renderState.attrs[key])}function scrapeMotionValuesFromProps$1(props){const {style}=
props,newValues={};for(const key in style)if(isMotionValue(style[key])||isForcedMotionValue(key,props))newValues[key]=style[key];return newValues}function scrapeMotionValuesFromProps(props){const newValues=scrapeMotionValuesFromProps$1(props);for(const key in props)if(isMotionValue(props[key])){const targetKey="x"===key||"y"===key?"attr"+key.toUpperCase():key;newValues[targetKey]=props[key]}return newValues}function resolveVariantFromProps(props,definition,custom,currentValues,currentVelocity){currentValues=
void 0===currentValues?{}:currentValues;currentVelocity=void 0===currentVelocity?{}:currentVelocity;"function"===typeof definition&&(definition=definition(void 0!==custom?custom:props.custom,currentValues,currentVelocity));"string"===typeof definition&&(definition=props.variants&&props.variants[definition]);"function"===typeof definition&&(definition=definition(void 0!==custom?custom:props.custom,currentValues,currentVelocity));return definition}function resolveMotionValue(value){return(value=isMotionValue(value)?
value.get():value)&&"object"===typeof value&&value.mix&&value.toValue?value.toValue():value}function makeState($jscomp$destructuring$var11,props,context,presenceContext){var {scrapeMotionValuesFromProps,createRenderState,onMount}=$jscomp$destructuring$var11;const state={latestValues:makeLatestValues(props,context,presenceContext,scrapeMotionValuesFromProps),renderState:createRenderState()};onMount&&(state.mount=instance=>onMount(props,instance,state));return state}function makeLatestValues(props,
context,presenceContext,scrapeMotionValues){const values={};scrapeMotionValues=scrapeMotionValues(props);for(var key$jscomp$0 in scrapeMotionValues)values[key$jscomp$0]=resolveMotionValue(scrapeMotionValues[key$jscomp$0]);let {initial,animate}=props;key$jscomp$0=isControllingVariants(props);scrapeMotionValues=isVariantNode(props);context&&scrapeMotionValues&&!key$jscomp$0&&!1!==props.inherit&&(void 0===initial&&(initial=context.initial),void 0===animate&&(animate=context.animate));let isInitialAnimationBlocked=
presenceContext?!1===presenceContext.initial:!1;(context=(isInitialAnimationBlocked=isInitialAnimationBlocked||!1===initial)?animate:initial)&&"boolean"!==typeof context&&!isAnimationControls(context)&&(Array.isArray(context)?context:[context]).forEach(definition=>{if(definition=resolveVariantFromProps(props,definition)){var $jscomp$destructuring$var13=Object.assign({},definition);definition=definition.transitionEnd;$jscomp$destructuring$var13=(delete $jscomp$destructuring$var13.transitionEnd,delete $jscomp$destructuring$var13.transition,
$jscomp$destructuring$var13);for(const key in $jscomp$destructuring$var13){let valueTarget=$jscomp$destructuring$var13[key];Array.isArray(valueTarget)&&(valueTarget=valueTarget[isInitialAnimationBlocked?valueTarget.length-1:0]);null!==valueTarget&&(values[key]=valueTarget)}for(const key in definition)values[key]=definition[key]}});return values}function createDomMotionConfig(Component,$jscomp$destructuring$var15,preloadedFeatures,createVisualElement,projectionNodeConstructor){({forwardMotionProps:$jscomp$destructuring$var15=
!1}=$jscomp$destructuring$var15);const baseConfig=isSVGComponent(Component)?svgMotionConfig:htmlMotionConfig;return Object.assign({},baseConfig,{preloadedFeatures,useRender:createUseRender($jscomp$destructuring$var15),createVisualElement,projectionNodeConstructor,Component})}function addDomEvent(target,eventName,handler,options){options=void 0===options?{passive:!0}:options;target.addEventListener(eventName,handler,options);return()=>target.removeEventListener(eventName,handler)}function useDomEvent(ref,
eventName,handler,options){React.useEffect(()=>{const element=ref.current;if(handler&&element)return addDomEvent(element,eventName,handler,options)},[ref,eventName,handler,options])}function isMouseEvent(event){return"undefined"!==typeof PointerEvent&&event instanceof PointerEvent?"mouse"===event.pointerType:event instanceof MouseEvent}function filterPrimaryPointer(eventHandler){return event=>{const isMouseEvent=event instanceof MouseEvent;(!isMouseEvent||isMouseEvent&&0===event.button)&&eventHandler(event)}}
function extractEventInfo(event,pointType){pointType=void 0===pointType?"page":pointType;event.touches?(pointType=void 0===pointType?"page":pointType,event=event.touches[0]||event.changedTouches[0]||defaultPagePoint,event={x:event[pointType+"X"],y:event[pointType+"Y"]}):(pointType=void 0===pointType?"page":pointType,event={x:event[pointType+"X"],y:event[pointType+"Y"]});return{point:event}}function getPointerEventName(name){if(!isBrowser||null!==window.onpointerdown){if(isBrowser&&null===window.ontouchstart)return touchEventNames[name];
if(isBrowser&&null===window.onmousedown)return mouseEventNames[name]}return name}function addPointerEvent(target,eventName,handler,options){return addDomEvent(target,getPointerEventName(eventName),wrapHandler(handler,"pointerdown"===eventName),options)}function usePointerEvent(ref,eventName,handler,options){return useDomEvent(ref,getPointerEventName(eventName),handler&&wrapHandler(handler,"pointerdown"===eventName),options)}function createLock(name){let lock=null;return()=>null===lock?(lock=name,
()=>{lock=null}):!1}function getGlobalLock(drag){let lock=!1;if("y"===drag)lock=globalVerticalLock();else if("x"===drag)lock=globalHorizontalLock();else{const openHorizontal=globalHorizontalLock(),openVertical=globalVerticalLock();openHorizontal&&openVertical?lock=()=>{openHorizontal();openVertical()}:(openHorizontal&&openHorizontal(),openVertical&&openVertical())}return lock}function isDragActive(){const openGestureLock=getGlobalLock(!0);if(!openGestureLock)return!0;openGestureLock();return!1}function createHoverEvent(visualElement,
isActive,callback){return(event,info)=>{isMouseEvent(event)&&!isDragActive()&&(visualElement.animationState&&visualElement.animationState.setActive(exports.AnimationType.Hover,isActive),callback&&callback(event,info))}}function useUnmountEffect(callback){return React.useEffect(()=>()=>callback(),[])}function warnOnce(condition,message,element){condition||warned.has(message)||(console.warn(message),element&&console.warn(element),warned.add(message))}function initIntersectionObserver($jscomp$destructuring$var19){var $jscomp$destructuring$var21=
Object.assign({},$jscomp$destructuring$var19);$jscomp$destructuring$var19=$jscomp$destructuring$var19.root;$jscomp$destructuring$var21=(delete $jscomp$destructuring$var21.root,$jscomp$destructuring$var21);var lookupRoot=$jscomp$destructuring$var19||document;observers.has(lookupRoot)||observers.set(lookupRoot,{});lookupRoot=observers.get(lookupRoot);const key=JSON.stringify($jscomp$destructuring$var21);lookupRoot[key]||(lookupRoot[key]=new IntersectionObserver(fireAllObserverCallbacks,Object.assign({},
{root:$jscomp$destructuring$var19},$jscomp$destructuring$var21)));return lookupRoot[key]}function observeIntersection(element,options,callback){const rootInteresectionObserver=initIntersectionObserver(options);observerCallbacks.set(element,callback);rootInteresectionObserver.observe(element);return()=>{observerCallbacks.delete(element);rootInteresectionObserver.unobserve(element)}}function useIntersectionObserver(shouldObserve,state,visualElement,$jscomp$destructuring$var23){var {root,margin:rootMargin,
amount="some",once}=$jscomp$destructuring$var23;React.useEffect(()=>{if(shouldObserve&&visualElement.current)return observeIntersection(visualElement.current,{root:null===root||void 0===root?void 0:root.current,rootMargin,threshold:"number"===typeof amount?amount:thresholdNames[amount]},entry=>{var {isIntersecting}=entry;if(state.isInView!==isIntersecting&&(state.isInView=isIntersecting,!once||isIntersecting||!state.hasEnteredView)){isIntersecting&&(state.hasEnteredView=!0);visualElement.animationState&&
visualElement.animationState.setActive(exports.AnimationType.InView,isIntersecting);var props=visualElement.getProps();(isIntersecting=isIntersecting?props.onViewportEnter:props.onViewportLeave)&&isIntersecting(entry)}})},[shouldObserve,root,rootMargin,amount])}function useMissingIntersectionObserver(shouldObserve,state,visualElement,$jscomp$destructuring$var24){var {fallback=!0}=$jscomp$destructuring$var24;React.useEffect(()=>{shouldObserve&&fallback&&("production"!==env&&warnOnce(!1,"IntersectionObserver not available on this device. whileInView animations will trigger on mount."),
requestAnimationFrame(()=>{state.hasEnteredView=!0;const {onViewportEnter}=visualElement.getProps();onViewportEnter&&onViewportEnter(null);visualElement.animationState&&visualElement.animationState.setActive(exports.AnimationType.InView,!0)}))},[shouldObserve])}function usePresence(){const context=React.useContext(PresenceContext);if(null===context)return[!0,null];const {isPresent,onExitComplete,register}=context,id=React.useId();React.useEffect(()=>register(id),[]);return!isPresent&&onExitComplete?
[!1,()=>onExitComplete&&onExitComplete(id)]:[!0]}function shallowCompare(next,prev){if(!Array.isArray(prev))return!1;const prevLength=prev.length;if(prevLength!==next.length)return!1;for(let i=0;i<prevLength;i++)if(prev[i]!==next[i])return!1;return!0}function cubicBezier(mX1,mY1,mX2,mY2){return mX1===mY1&&mX2===mY2?noop:t=>{if(0!==t&&1!==t){var lowerBound=0,upperBound=1;let currentX,currentT,i=0;do currentT=lowerBound+(upperBound-lowerBound)/2,currentX=(((1-3*mX2+3*mX1)*currentT+(3*mX2-6*mX1))*currentT+
3*mX1)*currentT-t,0<currentX?upperBound=currentT:lowerBound=currentT;while(1E-7<Math.abs(currentX)&&12>++i);t=currentT;t*=((1-3*mY2+3*mY1)*t+(3*mY2-6*mY1))*t+3*mY1}return t}}function getAnimatableNone(key,value){var _a;key=defaultValueTypes[key];key!==styleValueTypes.filter&&(key=styleValueTypes.complex);return null===(_a=key.getAnimatableNone)||void 0===_a?void 0:_a.call(key,value)}function delay$jscomp$0(callback,timeout){const start=performance.now(),checkElapsed=$jscomp$destructuring$var25=>{({timestamp:$jscomp$destructuring$var25}=
$jscomp$destructuring$var25);$jscomp$destructuring$var25-=start;$jscomp$destructuring$var25>=timeout&&(sync.cancelSync.read(checkElapsed),callback($jscomp$destructuring$var25-timeout))};sync__default["default"].read(checkElapsed,!0);return()=>sync.cancelSync.read(checkElapsed)}function hueToRgb(p,q,t){0>t&&(t+=1);1<t&&--t;return t<1/6?p+6*(q-p)*t:.5>t?q:t<2/3?p+(q-p)*(2/3-t)*6:p}function asRGBA(color){var type=getColorType(color);heyListen.invariant(!!type,`'${color}' is not an animatable color. Use the equivalent color code instead.`);
color=type.parse(color);if(type===styleValueTypes.hsla){var {hue,saturation,lightness,alpha}=color;hue/=360;saturation/=100;lightness/=100;if(saturation){var blue=.5>lightness?lightness*(1+saturation):lightness+saturation-lightness*saturation;const p=2*lightness-blue;type=hueToRgb(p,blue,hue+1/3);color=hueToRgb(p,blue,hue);blue=hueToRgb(p,blue,hue-1/3)}else type=color=blue=lightness;color={red:Math.round(255*type),green:Math.round(255*color),blue:Math.round(255*blue),alpha}}return color}function getMixer$1(origin,
target){return"number"===typeof origin?v=>-v*origin+v*target+origin:styleValueTypes.color.test(origin)?mixColor(origin,target):mixComplex(origin,target)}function analyse(value){value=styleValueTypes.complex.parse(value);const numValues=value.length;let numNumbers=0,numColors=0;for(let i=0;i<numValues;i++)numNumbers||"number"===typeof value[i]?numNumbers++:numColors++;return{parsed:value,numNumbers,numColors}}function detectMixerFactory(v){if("number"!==typeof v){if("string"===typeof v)return styleValueTypes.color.test(v)?
mixColor:mixComplex;if(Array.isArray(v))return mixArray;if("object"===typeof v)return mixObject}return mixNumber}function createMixers(output,ease,customMixer){const mixers=[];customMixer=customMixer||detectMixerFactory(output[0]);const numMixers=output.length-1;for(let i=0;i<numMixers;i++){let mixer=customMixer(output[i],output[i+1]);ease&&(mixer=[Array.isArray(ease)?ease[i]:ease,mixer].reduce(combineFunctions));mixers.push(mixer)}return mixers}function interpolate(input,output,$jscomp$destructuring$var27){var {clamp:isClamp=
!0,ease,mixer}=void 0===$jscomp$destructuring$var27?{}:$jscomp$destructuring$var27;const inputLength=input.length;heyListen.invariant(inputLength===output.length,"Both input and output ranges must be the same length");heyListen.invariant(!ease||!Array.isArray(ease)||ease.length===inputLength-1,"Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.");input[0]>input[inputLength-1]&&(input=[...input].reverse(),output=[...output].reverse());
const mixers=createMixers(output,ease,mixer),numMixers=mixers.length,interpolator=v=>{let i=0;if(1<numMixers)for(;i<input.length-2&&!(v<input[i+1]);i++);v=progress$jscomp$0(input[i],input[i+1],v);return mixers[i](v)};return isClamp?v=>interpolator(clamp(input[0],input[inputLength-1],v)):interpolator}function defaultEasing(values,easing){return values.map(()=>easing||easeInOut).splice(0,values.length-1)}function defaultOffset(values){const numValues=values.length;return values.map((_value,i)=>0!==
i?i/(numValues-1):0)}function convertOffsetToTimes(offset,duration){return offset.map(o=>o*duration)}function findSpring($jscomp$destructuring$var29){var {duration=800,bounce=.25,velocity=0,mass=1}=$jscomp$destructuring$var29;let envelope;heyListen.warning(1E4>=duration,"Spring duration must be 10 seconds or less");let dampingRatio=1-bounce;dampingRatio=clamp(.05,1,dampingRatio);duration=clamp(.01,10,duration/1E3);1>dampingRatio?(envelope=undampedFreq=>{const exponentialDecay=undampedFreq*dampingRatio;
return.001-(exponentialDecay-velocity)/(undampedFreq*Math.sqrt(1-dampingRatio*dampingRatio))*Math.exp(-(exponentialDecay*duration))},$jscomp$destructuring$var29=undampedFreq=>{var delta=undampedFreq*dampingRatio*duration;const d=delta*velocity+velocity,e=Math.pow(dampingRatio,2)*Math.pow(undampedFreq,2)*duration;delta=Math.exp(-delta);const g=Math.pow(undampedFreq,2)*Math.sqrt(1-dampingRatio*dampingRatio);return(0<-envelope(undampedFreq)+.001?-1:1)*(d-e)*delta/g}):(envelope=undampedFreq=>-.001+Math.exp(-undampedFreq*
duration)*((undampedFreq-velocity)*duration+1),$jscomp$destructuring$var29=undampedFreq=>Math.exp(-undampedFreq*duration)*(velocity-undampedFreq)*duration*duration);$jscomp$destructuring$var29=approximateRoot(envelope,$jscomp$destructuring$var29,5/duration);duration*=1E3;if(isNaN($jscomp$destructuring$var29))return{stiffness:100,damping:10,duration};$jscomp$destructuring$var29=Math.pow($jscomp$destructuring$var29,2)*mass;return{stiffness:$jscomp$destructuring$var29,damping:2*dampingRatio*Math.sqrt(mass*
$jscomp$destructuring$var29),duration}}function approximateRoot(envelope,derivative,initialGuess){for(let i=1;12>i;i++)initialGuess-=envelope(initialGuess)/derivative(initialGuess);return initialGuess}function isSpringType(options,keys){return keys.some(key=>void 0!==options[key])}function getSpringOptions(options){let springOptions=Object.assign({},{velocity:0,stiffness:100,damping:10,mass:1,isResolvedFromDuration:!1},options);!isSpringType(options,physicsKeys)&&isSpringType(options,durationKeys)&&
(options=findSpring(options),springOptions=Object.assign({},springOptions,options,{velocity:0,mass:1}),springOptions.isResolvedFromDuration=!0);return springOptions}function spring($jscomp$destructuring$var30){function createSpring(){const initialVelocity=velocity?-(velocity/1E3):0,initialDelta=to-from,dampingRatio=damping/(2*Math.sqrt(stiffness*mass)),undampedAngularFreq=Math.sqrt(stiffness/mass)/1E3;void 0===restDelta&&(restDelta=Math.min(Math.abs(to-from)/100,.4));if(1>dampingRatio){const angularFreq=
undampedAngularFreq*Math.sqrt(1-dampingRatio*dampingRatio);resolveSpring=t=>to-Math.exp(-dampingRatio*undampedAngularFreq*t)*((initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)/angularFreq*Math.sin(angularFreq*t)+initialDelta*Math.cos(angularFreq*t));resolveVelocity=t=>{const envelope=Math.exp(-dampingRatio*undampedAngularFreq*t);return dampingRatio*undampedAngularFreq*envelope*(Math.sin(angularFreq*t)*(initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)/angularFreq+initialDelta*
Math.cos(angularFreq*t))-envelope*(Math.cos(angularFreq*t)*(initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)-angularFreq*initialDelta*Math.sin(angularFreq*t))}}else if(1===dampingRatio)resolveSpring=t=>to-Math.exp(-undampedAngularFreq*t)*(initialDelta+(initialVelocity+undampedAngularFreq*initialDelta)*t);else{const dampedAngularFreq=undampedAngularFreq*Math.sqrt(dampingRatio*dampingRatio-1);resolveSpring=t=>{const freqForT=Math.min(dampedAngularFreq*t,300);return to-Math.exp(-dampingRatio*
undampedAngularFreq*t)*((initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)*Math.sinh(freqForT)+dampedAngularFreq*initialDelta*Math.cosh(freqForT))/dampedAngularFreq}}}var $jscomp$destructuring$var32=Object.assign({},$jscomp$destructuring$var30),from=void 0===$jscomp$destructuring$var30.from?0:$jscomp$destructuring$var30.from,to=void 0===$jscomp$destructuring$var30.to?1:$jscomp$destructuring$var30.to,restSpeed=void 0===$jscomp$destructuring$var30.restSpeed?2:$jscomp$destructuring$var30.restSpeed,
restDelta=void 0===$jscomp$destructuring$var30.restDelta?.01:$jscomp$destructuring$var30.restDelta;$jscomp$destructuring$var30=(delete $jscomp$destructuring$var32.from,delete $jscomp$destructuring$var32.to,delete $jscomp$destructuring$var32.restSpeed,delete $jscomp$destructuring$var32.restDelta,$jscomp$destructuring$var32);const state={done:!1,value:from};let {stiffness,damping,mass,velocity,duration,isResolvedFromDuration}=getSpringOptions($jscomp$destructuring$var30),resolveSpring=zero,resolveVelocity=
zero;createSpring();return{next:t=>{const current=resolveSpring(t);if(isResolvedFromDuration)state.done=t>=duration;else{t=1E3*resolveVelocity(t);const isBelowDisplacementThreshold=Math.abs(to-current)<=restDelta;state.done=Math.abs(t)<=restSpeed&&isBelowDisplacementThreshold}state.value=state.done?to:current;return state},flipTarget:()=>{velocity=-velocity;[from,to]=[to,from];createSpring()}}}function animate$1($jscomp$destructuring$var35){function update(delta){isForwardPlayback||(delta=-delta);
elapsed+=delta;isComplete||(delta=animation.next(Math.max(0,elapsed)),latest=delta.value,interpolateFromNumber&&(latest=interpolateFromNumber(latest)),isComplete=isForwardPlayback?delta.done:0>=elapsed);null===onUpdate||void 0===onUpdate?void 0:onUpdate(latest);if(isComplete)if(0===repeatCount&&(null!==computedDuration&&void 0!==computedDuration?computedDuration:computedDuration=elapsed),repeatCount<repeatMax){if(isForwardPlayback?elapsed>=computedDuration+repeatDelay:elapsed<=-repeatDelay){repeatCount++;
if("reverse"===repeatType){isForwardPlayback=0===repeatCount%2;delta=elapsed;var duration=computedDuration,delay=repeatDelay;duration=void 0===duration?0:duration;delay=void 0===delay?0:delay;elapsed=void 0===isForwardPlayback||isForwardPlayback?duration+-delta-duration-(void 0===delay?0:delay):duration-(delta-duration)+delay}else elapsed=elapsed-computedDuration-(void 0===repeatDelay?0:repeatDelay),"mirror"===repeatType&&animation.flipTarget();isComplete=!1;onRepeat&&onRepeat()}}else driverControls.stop(),
onComplete&&onComplete()}var $jscomp$destructuring$var37=Object.assign({},$jscomp$destructuring$var35),from=$jscomp$destructuring$var35.from,autoplay=void 0===$jscomp$destructuring$var35.autoplay?!0:$jscomp$destructuring$var35.autoplay,driver=void 0===$jscomp$destructuring$var35.driver?framesync:$jscomp$destructuring$var35.driver,elapsed=void 0===$jscomp$destructuring$var35.elapsed?0:$jscomp$destructuring$var35.elapsed,repeatMax=void 0===$jscomp$destructuring$var35.repeat?0:$jscomp$destructuring$var35.repeat,
repeatType=void 0===$jscomp$destructuring$var35.repeatType?"loop":$jscomp$destructuring$var35.repeatType,repeatDelay=void 0===$jscomp$destructuring$var35.repeatDelay?0:$jscomp$destructuring$var35.repeatDelay,onPlay=$jscomp$destructuring$var35.onPlay,onStop=$jscomp$destructuring$var35.onStop,onComplete=$jscomp$destructuring$var35.onComplete,onRepeat=$jscomp$destructuring$var35.onRepeat,onUpdate=$jscomp$destructuring$var35.onUpdate;$jscomp$destructuring$var35=void 0===$jscomp$destructuring$var35.type?
"keyframes":$jscomp$destructuring$var35.type;$jscomp$destructuring$var37=(delete $jscomp$destructuring$var37.from,delete $jscomp$destructuring$var37.autoplay,delete $jscomp$destructuring$var37.driver,delete $jscomp$destructuring$var37.elapsed,delete $jscomp$destructuring$var37.repeat,delete $jscomp$destructuring$var37.repeatType,delete $jscomp$destructuring$var37.repeatDelay,delete $jscomp$destructuring$var37.onPlay,delete $jscomp$destructuring$var37.onStop,delete $jscomp$destructuring$var37.onComplete,
delete $jscomp$destructuring$var37.onRepeat,delete $jscomp$destructuring$var37.onUpdate,delete $jscomp$destructuring$var37.type,$jscomp$destructuring$var37);var _b;let {to}=$jscomp$destructuring$var37,driverControls,repeatCount=0,computedDuration=$jscomp$destructuring$var37.duration,latest,isComplete=!1,isForwardPlayback=!0,interpolateFromNumber;$jscomp$destructuring$var35=types[Array.isArray(to)?"keyframes":$jscomp$destructuring$var35];if(null===(_b=$jscomp$destructuring$var35.needsInterpolation)||
void 0===_b?0:_b.call($jscomp$destructuring$var35,from,to))interpolateFromNumber=interpolate([0,100],[from,to],{clamp:!1}),from=0,to=100;const animation=$jscomp$destructuring$var35(Object.assign({},$jscomp$destructuring$var37,{from,to}));autoplay&&(null===onPlay||void 0===onPlay?void 0:onPlay(),driverControls=driver(update),driverControls.start());return{stop:()=>{null===onStop||void 0===onStop?void 0:onStop();driverControls.stop()}}}function inertia($jscomp$destructuring$var38){function boundaryNearest(v){return void 0===
min?max:void 0===max?min:Math.abs(min-v)<Math.abs(max-v)?min:max}function startAnimation(options){null===currentAnimation||void 0===currentAnimation?void 0:currentAnimation.stop();currentAnimation=animate$1(Object.assign({},options,{driver,onUpdate:v=>{var _a;null===onUpdate||void 0===onUpdate?void 0:onUpdate(v);null===(_a=options.onUpdate)||void 0===_a?void 0:_a.call(options,v)},onComplete,onStop}))}function startSpring(options){startAnimation(Object.assign({},{type:"spring",stiffness:bounceStiffness,
damping:bounceDamping,restDelta},options))}var {from=0,velocity=0,min,max,power=.8,timeConstant=750,bounceStiffness=500,bounceDamping=10,restDelta=1,modifyTarget,driver,onUpdate,onComplete,onStop}=$jscomp$destructuring$var38;let currentAnimation;if(void 0!==min&&from<min||void 0!==max&&from>max)startSpring({from,velocity,to:boundaryNearest(from)});else{$jscomp$destructuring$var38=power*velocity+from;"undefined"!==typeof modifyTarget&&($jscomp$destructuring$var38=modifyTarget($jscomp$destructuring$var38));
const boundary=boundaryNearest($jscomp$destructuring$var38),heading=boundary===min?-1:1;let prev,current;const checkBoundary=v=>{prev=current;current=v;var frameDuration=sync.getFrameData().delta;velocity=frameDuration?1E3/frameDuration*(v-prev):0;(1===heading&&v>boundary||-1===heading&&v<boundary)&&startSpring({from:v,to:boundary,velocity})};startAnimation({type:"decay",from,velocity,timeConstant,power,restDelta,modifyTarget,onUpdate:void 0!==min&&$jscomp$destructuring$var38<min||void 0!==max&&$jscomp$destructuring$var38>
max?checkBoundary:void 0})}return{stop:()=>null===currentAnimation||void 0===currentAnimation?void 0:currentAnimation.stop()}}function getDelayFromTransition(transition,key){var _a,_b;return null!==(_b=null!==(_a=(transition[key]||transition["default"]||transition||{}).delay)&&void 0!==_a?_a:transition.delay)&&void 0!==_b?_b:0}function getPopmotionAnimationOptions(transition,options$jscomp$0,key){Array.isArray(options$jscomp$0.to)&&void 0===transition.duration&&(transition.duration=.8);Array.isArray(options$jscomp$0.to)&&
null===options$jscomp$0.to[0]&&(options$jscomp$0.to=[...options$jscomp$0.to],options$jscomp$0.to[0]=options$jscomp$0.from);var $jscomp$inline_2240=Object.assign({},transition);$jscomp$inline_2240=(delete $jscomp$inline_2240.when,delete $jscomp$inline_2240.delay,delete $jscomp$inline_2240.delayChildren,delete $jscomp$inline_2240.staggerChildren,delete $jscomp$inline_2240.staggerDirection,delete $jscomp$inline_2240.repeat,delete $jscomp$inline_2240.repeatType,delete $jscomp$inline_2240.repeatDelay,
delete $jscomp$inline_2240.from,$jscomp$inline_2240);if(!Object.keys($jscomp$inline_2240).length){$jscomp$inline_2240=Object;var JSCompiler_temp_const=$jscomp$inline_2240.assign,to=options$jscomp$0.to;key=Array.isArray(to)?keyframes$1:defaultTransitions[key]||defaultTransitions.default;key=Object.assign({},{to},key(to));transition=JSCompiler_temp_const.call($jscomp$inline_2240,{},transition,key)}key=Object;$jscomp$inline_2240=key.assign;var $jscomp$inline_2257=transition,$jscomp$inline_2258=Object.assign({},
$jscomp$inline_2257);transition=$jscomp$inline_2257.ease;var times=$jscomp$inline_2257.times;JSCompiler_temp_const=$jscomp$inline_2257.yoyo;to=$jscomp$inline_2257.flip;$jscomp$inline_2257=$jscomp$inline_2257.loop;$jscomp$inline_2258=(delete $jscomp$inline_2258.ease,delete $jscomp$inline_2258.times,delete $jscomp$inline_2258.yoyo,delete $jscomp$inline_2258.flip,delete $jscomp$inline_2258.loop,$jscomp$inline_2258);const options=Object.assign({},$jscomp$inline_2258);times&&(options.offset=times);$jscomp$inline_2258.duration&&
(options.duration=1E3*$jscomp$inline_2258.duration);$jscomp$inline_2258.repeatDelay&&(options.repeatDelay=1E3*$jscomp$inline_2258.repeatDelay);transition&&(times=Array.isArray(transition)&&"number"!==typeof transition[0],options.ease=times?transition.map(easingDefinitionToFunction):easingDefinitionToFunction(transition));"tween"===$jscomp$inline_2258.type&&(options.type="keyframes");if(JSCompiler_temp_const||$jscomp$inline_2257||to)heyListen.warning(!legacyRepeatWarning,"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options."),
legacyRepeatWarning=!0,JSCompiler_temp_const?options.repeatType="reverse":$jscomp$inline_2257?options.repeatType="loop":to&&(options.repeatType="mirror"),options.repeat=$jscomp$inline_2257||JSCompiler_temp_const||to||$jscomp$inline_2258.repeat;"spring"!==$jscomp$inline_2258.type&&(options.type="keyframes");return $jscomp$inline_2240.call(key,{},options$jscomp$0,options)}function getAnimation(key,value,target,transition,onComplete){function start(){const options={from:origin,to:target,velocity:value.getVelocity(),
onComplete,onUpdate:v=>value.set(v)};return"inertia"===valueTransition.type||"decay"===valueTransition.type?inertia(Object.assign({},options,valueTransition)):animate$1(Object.assign({},getPopmotionAnimationOptions(valueTransition,options,key),{onUpdate:v=>{options.onUpdate(v);valueTransition.onUpdate&&valueTransition.onUpdate(v)},onComplete:()=>{options.onComplete();valueTransition.onComplete&&valueTransition.onComplete()}}))}function set(){const finalTarget=resolveFinalValueInKeyframes(target);
value.set(finalTarget);onComplete();valueTransition.onUpdate&&valueTransition.onUpdate(finalTarget);valueTransition.onComplete&&valueTransition.onComplete();return{stop:()=>{}}}const valueTransition=transition[key]||transition["default"]||transition||{};let origin=void 0!==valueTransition.from?valueTransition.from:value.get();transition=isAnimatable(key,target);"none"===origin&&transition&&"string"===typeof target?origin=getAnimatableNone(key,target):isZero(origin)&&"string"===typeof target?origin=
"number"===typeof target?0:getAnimatableNone("",target):!Array.isArray(target)&&isZero(target)&&"string"===typeof origin&&(target="number"===typeof origin?0:getAnimatableNone("",origin));const isOriginAnimatable=isAnimatable(key,origin);heyListen.warning(isOriginAnimatable===transition,`You are trying to animate ${key} from "${origin}" to "${target}". ${origin} is not an animatable value - to enable this animation set ${origin} to a value animatable to ${target} via the \`style\` property.`);return isOriginAnimatable&&
transition&&!1!==valueTransition.type?start:set}function isZero(value){return 0===value||"string"===typeof value&&0===parseFloat(value)&&-1===value.indexOf(" ")}function startAnimation(key,value,target,transition){transition=void 0===transition?{}:transition;instantAnimationState.current&&(transition={type:!1});return value.start(onComplete=>{let controls;const animation=getAnimation(key,value,target,transition,onComplete);onComplete=getDelayFromTransition(transition,key);let cancelDelay;onComplete?
cancelDelay=delay$jscomp$0(()=>controls=animation(),1E3*onComplete):controls=animation();return()=>{cancelDelay&&cancelDelay();controls&&controls.stop()}})}function addUniqueItem(arr,item){-1===arr.indexOf(item)&&arr.push(item)}function removeItem(arr,item){item=arr.indexOf(item);-1<item&&arr.splice(item,1)}function moveItem($jscomp$destructuring$var45,fromIndex,toIndex){[...$jscomp$destructuring$var45]=$jscomp$destructuring$var45;const startIndex=0>fromIndex?$jscomp$destructuring$var45.length+fromIndex:
fromIndex;0<=startIndex&&startIndex<$jscomp$destructuring$var45.length&&(toIndex=0>toIndex?$jscomp$destructuring$var45.length+toIndex:toIndex,[fromIndex]=$jscomp$destructuring$var45.splice(fromIndex,1),$jscomp$destructuring$var45.splice(toIndex,0,fromIndex));return $jscomp$destructuring$var45}function motionValue$jscomp$0(init){return new MotionValue(init)}function getCurrent(visualElement){const current={};visualElement.values.forEach((value,key)=>current[key]=value.get());return current}function getVelocity$1(visualElement){const velocity=
{};visualElement.values.forEach((value,key)=>velocity[key]=value.getVelocity());return velocity}function resolveVariant(visualElement,definition,custom){const props=visualElement.getProps();return resolveVariantFromProps(props,definition,void 0!==custom?custom:props.custom,getCurrent(visualElement),getVelocity$1(visualElement))}function setTarget(visualElement,definition){var $jscomp$destructuring$var47=(definition=resolveVariant(visualElement,definition))?visualElement.makeTargetAnimatable(definition,
!1):{};definition=Object.assign({},$jscomp$destructuring$var47);$jscomp$destructuring$var47=void 0===$jscomp$destructuring$var47.transitionEnd?{}:$jscomp$destructuring$var47.transitionEnd;definition=(delete definition.transitionEnd,delete definition.transition,definition);definition=Object.assign({},definition,$jscomp$destructuring$var47);for(const key in definition){var value=resolveFinalValueInKeyframes(definition[key]);$jscomp$destructuring$var47=visualElement;var key$jscomp$0=key;$jscomp$destructuring$var47.hasValue(key$jscomp$0)?
$jscomp$destructuring$var47.getValue(key$jscomp$0).set(value):$jscomp$destructuring$var47.addValue(key$jscomp$0,motionValue$jscomp$0(value))}}function setVariants(visualElement,variantLabels){[...variantLabels].reverse().forEach(key=>{var _a;(key=visualElement.getVariant(key))&&setTarget(visualElement,key);null===(_a=visualElement.variantChildren)||void 0===_a?void 0:_a.forEach(child=>{setVariants(child,variantLabels)})})}function checkTargetForNewValues(visualElement,target,origin){var _a,_b;const newValueKeys=
Object.keys(target).filter(key=>!visualElement.hasValue(key)),numNewValues=newValueKeys.length;if(numNewValues)for(let i=0;i<numNewValues;i++){const key=newValueKeys[i],targetValue=target[key];let value=null;Array.isArray(targetValue)&&(value=targetValue[0]);null===value&&(value=null!==(_b=null!==(_a=origin[key])&&void 0!==_a?_a:visualElement.readValue(key))&&void 0!==_b?_b:target[key]);void 0!==value&&null!==value&&("string"===typeof value&&(/^\-?\d*\.?\d+$/.test(value)||/^0[^.\s]+$/.test(value))?
value=parseFloat(value):!valueTypes.find(testValueType(value))&&styleValueTypes.complex.test(targetValue)&&(value=getAnimatableNone(key,targetValue)),visualElement.addValue(key,motionValue$jscomp$0(value)),void 0===origin[key]&&(origin[key]=value),null!==value&&visualElement.setBaseTarget(key,value))}}function getOrigin(target,transition,visualElement){var _a;const origin={};for(const key in target)target=transition?(transition[key]||transition["default"]||transition).from:void 0,origin[key]=void 0!==
target?target:null===(_a=visualElement.getValue(key))||void 0===_a?void 0:_a.get();return origin}function isWillChangeMotionValue(value){return!(!isMotionValue(value)||!value.add)}function animateVisualElement(visualElement,definition,options){options=void 0===options?{}:options;visualElement.notify("AnimationStart",definition);if(Array.isArray(definition)){var animation=definition.map(variant=>animateVariant(visualElement,variant,options));animation=Promise.all(animation)}else"string"===typeof definition?
animation=animateVariant(visualElement,definition,options):(animation="function"===typeof definition?resolveVariant(visualElement,definition,options.custom):definition,animation=animateTarget(visualElement,animation,options));return animation.then(()=>visualElement.notify("AnimationComplete",definition))}function animateVariant(visualElement,variant,options){options=void 0===options?{}:options;var _a;const resolved=resolveVariant(visualElement,variant,options.custom);let {transition=visualElement.getDefaultTransition()||
{}}=resolved||{};options.transitionOverride&&(transition=options.transitionOverride);const getAnimation=resolved?()=>animateTarget(visualElement,resolved,options):()=>Promise.resolve(),getChildAnimations=(null===(_a=visualElement.variantChildren)||void 0===_a?0:_a.size)?forwardDelay=>{const {delayChildren=0,staggerChildren,staggerDirection}=transition;return animateChildren(visualElement,variant,delayChildren+(void 0===forwardDelay?0:forwardDelay),staggerChildren,staggerDirection,options)}:()=>Promise.resolve();
({when:_a}=transition);if(_a){const [first,last]="beforeChildren"===_a?[getAnimation,getChildAnimations]:[getChildAnimations,getAnimation];return first().then(last)}return Promise.all([getAnimation(),getChildAnimations(options.delay)])}function animateTarget(visualElement,definition,$jscomp$destructuring$var49){var {delay=0,transitionOverride,type}=void 0===$jscomp$destructuring$var49?{}:$jscomp$destructuring$var49,_a;$jscomp$destructuring$var49=visualElement.makeTargetAnimatable(definition);var $jscomp$destructuring$var51=
Object.assign({},$jscomp$destructuring$var49);definition=void 0===$jscomp$destructuring$var49.transition?visualElement.getDefaultTransition():$jscomp$destructuring$var49.transition;let transitionEnd=$jscomp$destructuring$var49.transitionEnd;$jscomp$destructuring$var49=(delete $jscomp$destructuring$var51.transition,delete $jscomp$destructuring$var51.transitionEnd,$jscomp$destructuring$var51);const willChange=visualElement.getValue("willChange");transitionOverride&&(definition=transitionOverride);$jscomp$destructuring$var51=
[];const animationTypeState=type&&(null===(_a=visualElement.animationState)||void 0===_a?void 0:_a.getState()[type]);for(const key in $jscomp$destructuring$var49){_a=visualElement.getValue(key);const valueTarget=$jscomp$destructuring$var49[key];if(!_a||void 0===valueTarget||animationTypeState&&shouldBlockAnimation(animationTypeState,key))continue;let valueTransition=Object.assign({},{delay},definition);visualElement.shouldReduceMotion&&transformProps.has(key)&&(valueTransition=Object.assign({},valueTransition,
{type:!1,delay:0}));_a=startAnimation(key,_a,valueTarget,valueTransition);isWillChangeMotionValue(willChange)&&(willChange.add(key),_a=_a.then(()=>willChange.remove(key)));$jscomp$destructuring$var51.push(_a)}return Promise.all($jscomp$destructuring$var51).then(()=>{transitionEnd&&setTarget(visualElement,transitionEnd)})}function animateChildren(visualElement,variant,delayChildren,staggerChildren,staggerDirection,options){delayChildren=void 0===delayChildren?0:delayChildren;staggerChildren=void 0===
staggerChildren?0:staggerChildren;const animations=[],maxStaggerDuration=(visualElement.variantChildren.size-1)*staggerChildren,generateStaggerDuration=1===(void 0===staggerDirection?1:staggerDirection)?i=>(void 0===i?0:i)*staggerChildren:i=>maxStaggerDuration-(void 0===i?0:i)*staggerChildren;Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child,i)=>{animations.push(animateVariant(child,variant,Object.assign({},options,{delay:delayChildren+generateStaggerDuration(i)})).then(()=>
child.notify("AnimationComplete",variant)))});return Promise.all(animations)}function stopAnimation(visualElement){visualElement.values.forEach(value=>value.stop())}function sortByTreeOrder(a,b){return a.sortNodePosition(b)}function shouldBlockAnimation($jscomp$destructuring$var52,key){var {protectedKeys,needsAnimating}=$jscomp$destructuring$var52;$jscomp$destructuring$var52=protectedKeys.hasOwnProperty(key)&&!0!==needsAnimating[key];needsAnimating[key]=!1;return $jscomp$destructuring$var52}function animateList(visualElement){return animations=>
Promise.all(animations.map($jscomp$destructuring$var53=>{var {animation,options}=$jscomp$destructuring$var53;return animateVisualElement(visualElement,animation,options)}))}function createAnimationState(visualElement){function animateChanges(options,changedActiveType){var _a;const props=visualElement.getProps(),context=visualElement.getVariantContext(!0)||{},animations=[],removedKeys=new Set;let encounteredKeys={},removedVariantIndex=Infinity;for(let i=0;i<numAnimationTypes;i++){const type=reversePriorityOrder[i],
typeState=state[type],prop=null!==(_a=props[type])&&void 0!==_a?_a:context[type];var propIsVariant=isVariantLabel(prop),activeDelta=type===changedActiveType?typeState.isActive:null;!1===activeDelta&&(removedVariantIndex=i);let isInherited=prop===context[type]&&prop!==props[type]&&propIsVariant;isInherited&&isInitialRender&&visualElement.manuallyAnimateOnMount&&(isInherited=!1);typeState.protectedKeys=Object.assign({},encounteredKeys);if(!typeState.isActive&&null===activeDelta||!prop&&!typeState.prevProp||
isAnimationControls(prop)||"boolean"===typeof prop)continue;const variantDidChange=checkVariantsDidChange(typeState.prevProp,prop);let shouldAnimateType=variantDidChange||type===changedActiveType&&typeState.isActive&&!isInherited&&propIsVariant||i>removedVariantIndex&&propIsVariant;propIsVariant=Array.isArray(prop)?prop:[prop];let resolvedValues=propIsVariant.reduce(buildResolvedTypeValues,{});!1===activeDelta&&(resolvedValues={});({prevResolvedValues:activeDelta={}}=typeState);var allKeys=Object.assign({},
activeDelta,resolvedValues);const markToAnimate=key=>{shouldAnimateType=!0;removedKeys.delete(key);typeState.needsAnimating[key]=!0};for(const key in allKeys){allKeys=resolvedValues[key];const prev=activeDelta[key];encounteredKeys.hasOwnProperty(key)||(allKeys!==prev?Array.isArray(allKeys)&&Array.isArray(prev)?!shallowCompare(allKeys,prev)||variantDidChange?markToAnimate(key):typeState.protectedKeys[key]=!0:void 0!==allKeys?markToAnimate(key):removedKeys.add(key):void 0!==allKeys&&removedKeys.has(key)?
markToAnimate(key):typeState.protectedKeys[key]=!0)}typeState.prevProp=prop;typeState.prevResolvedValues=resolvedValues;typeState.isActive&&(encounteredKeys=Object.assign({},encounteredKeys,resolvedValues));isInitialRender&&visualElement.blockInitialAnimation&&(shouldAnimateType=!1);shouldAnimateType&&!isInherited&&animations.push(...propIsVariant.map(animation=>({animation,options:Object.assign({},{type},options)})))}if(removedKeys.size){const fallbackAnimation={};removedKeys.forEach(key=>{const fallbackTarget=
visualElement.getBaseTarget(key);void 0!==fallbackTarget&&(fallbackAnimation[key]=fallbackTarget)});animations.push({animation:fallbackAnimation})}changedActiveType=!!animations.length;isInitialRender&&!1===props.initial&&!visualElement.manuallyAnimateOnMount&&(changedActiveType=!1);isInitialRender=!1;return changedActiveType?animate(animations):Promise.resolve()}let animate=animateList(visualElement);const state={[exports.AnimationType.Animate]:createTypeState(!0),[exports.AnimationType.InView]:createTypeState(),
[exports.AnimationType.Hover]:createTypeState(),[exports.AnimationType.Tap]:createTypeState(),[exports.AnimationType.Drag]:createTypeState(),[exports.AnimationType.Focus]:createTypeState(),[exports.AnimationType.Exit]:createTypeState()};let isInitialRender=!0;const buildResolvedTypeValues=(acc,definition)=>{var resolved=resolveVariant(visualElement,definition);resolved&&(definition=Object.assign({},resolved),resolved=resolved.transitionEnd,definition=(delete definition.transition,delete definition.transitionEnd,
definition),acc=Object.assign({},acc,definition,resolved));return acc};return{animateChanges,setActive:function(type,isActive,options){var _a$jscomp$0;if(state[type].isActive===isActive)return Promise.resolve();null===(_a$jscomp$0=visualElement.variantChildren)||void 0===_a$jscomp$0?void 0:_a$jscomp$0.forEach(child=>{var _a;return null===(_a=child.animationState)||void 0===_a?void 0:_a.setActive(type,isActive)});state[type].isActive=isActive;options=animateChanges(options,type);for(const key in state)state[key].protectedKeys=
{};return options},setAnimateFunction:function(makeAnimator){animate=makeAnimator(visualElement)},getState:()=>state}}function checkVariantsDidChange(prev,next){return"string"===typeof next?next!==prev:Array.isArray(next)?!shallowCompare(next,prev):!1}function createTypeState(isActive){return{isActive:void 0===isActive?!1:isActive,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function distance2D(a,b){return Math.sqrt(Math.abs(a.x-b.x)**2+Math.abs(a.y-b.y)**2)}function transformPoint(info,
transformPagePoint){return transformPagePoint?{point:transformPagePoint(info.point)}:info}function subtractPoint(a,b){return{x:a.x-b.x,y:a.y-b.y}}function getPanInfo($jscomp$destructuring$var58,history){({point:$jscomp$destructuring$var58}=$jscomp$destructuring$var58);return{point:$jscomp$destructuring$var58,delta:subtractPoint($jscomp$destructuring$var58,history[history.length-1]),offset:subtractPoint($jscomp$destructuring$var58,history[0]),velocity:getVelocity(history,.1)}}function getVelocity(history,
timeDelta){if(2>history.length)return{x:0,y:0};let i=history.length-1;var timestampedPoint=null;const lastPoint=history[history.length-1];for(;0<=i;){timestampedPoint=history[i];if(lastPoint.timestamp-timestampedPoint.timestamp>1E3*timeDelta)break;i--}if(!timestampedPoint)return{x:0,y:0};history=(lastPoint.timestamp-timestampedPoint.timestamp)/1E3;if(0===history)return{x:0,y:0};timestampedPoint={x:(lastPoint.x-timestampedPoint.x)/history,y:(lastPoint.y-timestampedPoint.y)/history};Infinity===timestampedPoint.x&&
(timestampedPoint.x=0);Infinity===timestampedPoint.y&&(timestampedPoint.y=0);return timestampedPoint}function calcLength(axis){return axis.max-axis.min}function isNear(value,target,maxDistance){return Math.abs(value-(void 0===target?0:target))<=(void 0===maxDistance?.01:maxDistance)}function calcAxisDelta(delta,source,target,origin){delta.origin=void 0===origin?.5:origin;delta.originPoint=mix(source.min,source.max,delta.origin);delta.scale=calcLength(target)/calcLength(source);if(isNear(delta.scale,
1,1E-4)||isNaN(delta.scale))delta.scale=1;delta.translate=mix(target.min,target.max,delta.origin)-delta.originPoint;if(isNear(delta.translate)||isNaN(delta.translate))delta.translate=0}function calcBoxDelta(delta,source,target,origin){calcAxisDelta(delta.x,source.x,target.x,null===origin||void 0===origin?void 0:origin.originX);calcAxisDelta(delta.y,source.y,target.y,null===origin||void 0===origin?void 0:origin.originY)}function calcRelativePosition(target$jscomp$0,layout$jscomp$0,parent){var target=
target$jscomp$0.x,layout=layout$jscomp$0.x;target.min=layout.min-parent.x.min;target.max=target.min+calcLength(layout);target$jscomp$0=target$jscomp$0.y;layout$jscomp$0=layout$jscomp$0.y;target$jscomp$0.min=layout$jscomp$0.min-parent.y.min;target$jscomp$0.max=target$jscomp$0.min+calcLength(layout$jscomp$0)}function calcRelativeAxisConstraints(axis,min,max){return{min:void 0!==min?axis.min+min:void 0,max:void 0!==max?axis.max+max-(axis.max-axis.min):void 0}}function calcRelativeConstraints(layoutBox,
$jscomp$destructuring$var60){var {top,left,bottom,right}=$jscomp$destructuring$var60;return{x:calcRelativeAxisConstraints(layoutBox.x,left,right),y:calcRelativeAxisConstraints(layoutBox.y,top,bottom)}}function calcViewportAxisConstraints(layoutAxis,constraintsAxis){let min=constraintsAxis.min-layoutAxis.min,max=constraintsAxis.max-layoutAxis.max;constraintsAxis.max-constraintsAxis.min<layoutAxis.max-layoutAxis.min&&([min,max]=[max,min]);return{min,max}}function resolveDragElastic(dragElastic){dragElastic=
void 0===dragElastic?.35:dragElastic;!1===dragElastic?dragElastic=0:!0===dragElastic&&(dragElastic=.35);var JSCompiler_inline_result=dragElastic;JSCompiler_inline_result={min:resolvePointElastic(JSCompiler_inline_result,"left"),max:resolvePointElastic(JSCompiler_inline_result,"right")};dragElastic={min:resolvePointElastic(dragElastic,"top"),max:resolvePointElastic(dragElastic,"bottom")};return{x:JSCompiler_inline_result,y:dragElastic}}function resolvePointElastic(dragElastic,label){var _a;return"number"===
typeof dragElastic?dragElastic:null!==(_a=dragElastic[label])&&void 0!==_a?_a:0}function eachAxis(callback){return[callback("x"),callback("y")]}function convertBoundingBoxToBox($jscomp$destructuring$var61){var {top,left,right,bottom}=$jscomp$destructuring$var61;return{x:{min:left,max:right},y:{min:top,max:bottom}}}function transformBoxPoints(point,transformPoint){if(!transformPoint)return point;const topLeft=transformPoint({x:point.left,y:point.top});point=transformPoint({x:point.right,y:point.bottom});
return{top:topLeft.y,left:topLeft.x,bottom:point.y,right:point.x}}function hasScale($jscomp$destructuring$var63){var {scale,scaleX,scaleY}=$jscomp$destructuring$var63;return!(void 0===scale||1===scale)||!(void 0===scaleX||1===scaleX)||!(void 0===scaleY||1===scaleY)}function hasTransform(values){return hasScale(values)||has2DTranslate(values)||values.z||values.rotate||values.rotateX||values.rotateY}function has2DTranslate(values){return is2DTranslate(values.x)||is2DTranslate(values.y)}function is2DTranslate(value){return value&&
"0%"!==value}function applyPointDelta(point,translate,scale,originPoint,boxScale){void 0!==boxScale&&(point=originPoint+boxScale*(point-originPoint));return originPoint+scale*(point-originPoint)+translate}function applyAxisDelta(axis,translate,scale,originPoint,boxScale){translate=void 0===translate?0:translate;scale=void 0===scale?1:scale;axis.min=applyPointDelta(axis.min,translate,scale,originPoint,boxScale);axis.max=applyPointDelta(axis.max,translate,scale,originPoint,boxScale)}function applyBoxDelta(box,
$jscomp$destructuring$var64){var {x,y}=$jscomp$destructuring$var64;applyAxisDelta(box.x,x.translate,x.scale,x.originPoint);applyAxisDelta(box.y,y.translate,y.scale,y.originPoint)}function snapToDefault(scale){return Number.isInteger(scale)?scale:1.0000000000001<scale||.999999999999>scale?scale:1}function translateAxis(axis,distance){axis.min+=distance;axis.max+=distance}function transformAxis(axis,transforms,$jscomp$destructuring$var65){var [key,scaleKey,originKey]=$jscomp$destructuring$var65;$jscomp$destructuring$var65=
mix(axis.min,axis.max,void 0!==transforms[originKey]?transforms[originKey]:.5);applyAxisDelta(axis,transforms[key],transforms[scaleKey],$jscomp$destructuring$var65,transforms.scale)}function transformBox(box,transform){transformAxis(box.x,transform,xKeys$1);transformAxis(box.y,transform,yKeys$1)}function shouldDrag(direction,drag,currentDirection){return(!0===drag||drag===direction)&&(null===currentDirection||currentDirection===direction)}function isCSSVariable(value){return"string"===typeof value&&
value.startsWith("var(--")}function getVariableValue(current,element,depth){depth=void 0===depth?1:depth;heyListen.invariant(4>=depth,`Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);if(current=cssVariableRegex.exec(current)){var [,token,fallback]=current;current=[token,fallback]}else current=[,];const [token$jscomp$0,fallback$jscomp$0]=current;if(token$jscomp$0)return(current=window.getComputedStyle(element).getPropertyValue(token$jscomp$0))?
current.trim():isCSSVariable(fallback$jscomp$0)?getVariableValue(fallback$jscomp$0,element,depth+1):fallback$jscomp$0}function resolveCSSVariables(visualElement,$jscomp$destructuring$var69,transitionEnd){$jscomp$destructuring$var69=Object.assign({},$jscomp$destructuring$var69);const element=visualElement.current;if(!(element instanceof Element))return{target:$jscomp$destructuring$var69,transitionEnd};transitionEnd&&(transitionEnd=Object.assign({},transitionEnd));visualElement.values.forEach(value=>
{var current=value.get();isCSSVariable(current)&&(current=getVariableValue(current,element))&&value.set(current)});for(const key in $jscomp$destructuring$var69){visualElement=$jscomp$destructuring$var69[key];if(!isCSSVariable(visualElement))continue;const resolved=getVariableValue(visualElement,element);resolved&&($jscomp$destructuring$var69[key]=resolved,transitionEnd&&void 0===transitionEnd[key]&&(transitionEnd[key]=visualElement))}return{target:$jscomp$destructuring$var69,transitionEnd}}function removeNonTranslationalTransform(visualElement){const removedTransforms=
[];nonTranslationalTransformKeys.forEach(key=>{const value=visualElement.getValue(key);void 0!==value&&(removedTransforms.push([key,value.get()]),value.set(key.startsWith("scale")?1:0))});removedTransforms.length&&visualElement.render();return removedTransforms}function initPrefersReducedMotion(){JSCompiler_object_inline_current_5836=!0;if(isBrowser)if(window.matchMedia){const motionMediaQuery=window.matchMedia("(prefers-reduced-motion)");motionMediaQuery.addListener(()=>JSCompiler_object_inline_current_5835=
motionMediaQuery.matches);JSCompiler_object_inline_current_5835=motionMediaQuery.matches}else JSCompiler_object_inline_current_5835=!1}function pixelsToPercent(pixels,axis){return axis.max===axis.min?0:pixels/(axis.max-axis.min)*100}function animate$jscomp$0(from,to,transition){transition=void 0===transition?{}:transition;const value=isMotionValue(from)?from:motionValue$jscomp$0(from);startAnimation("",value,to,transition);return{stop:()=>value.stop(),isAnimating:()=>value.isAnimating()}}function getRadius(values,
radiusName){var _a;return null!==(_a=values[radiusName])&&void 0!==_a?_a:values.borderRadius}function compress(min,max,easing){return p=>p<min?0:p>max?1:easing(progress$jscomp$0(min,max,p))}function copyBoxInto(box,originBox){var axis=box.x,originAxis=originBox.x;axis.min=originAxis.min;axis.max=originAxis.max;box=box.y;originBox=originBox.y;box.min=originBox.min;box.max=originBox.max}function removePointDelta(point,translate,scale,originPoint,boxScale){point=originPoint+1/scale*(point-translate-
originPoint);void 0!==boxScale&&(point=originPoint+1/boxScale*(point-originPoint));return point}function removeAxisDelta(axis,translate,scale,origin,boxScale,originAxis,sourceAxis){translate=void 0===translate?0:translate;scale=void 0===scale?1:scale;origin=void 0===origin?.5:origin;originAxis=void 0===originAxis?axis:originAxis;sourceAxis=void 0===sourceAxis?axis:sourceAxis;styleValueTypes.percent.test(translate)&&(translate=parseFloat(translate),translate=mix(sourceAxis.min,sourceAxis.max,translate/
100)-sourceAxis.min);"number"===typeof translate&&(origin=mix(originAxis.min,originAxis.max,origin),axis===originAxis&&(origin-=translate),axis.min=removePointDelta(axis.min,translate,scale,origin,boxScale),axis.max=removePointDelta(axis.max,translate,scale,origin,boxScale))}function removeBoxTransforms(box,transforms,originBox,sourceBox){var [key,scaleKey,originKey]=xKeys;removeAxisDelta(box.x,transforms[key],transforms[scaleKey],transforms[originKey],transforms.scale,null===originBox||void 0===
originBox?void 0:originBox.x,null===sourceBox||void 0===sourceBox?void 0:sourceBox.x);var [key$jscomp$0,scaleKey$jscomp$0,originKey$jscomp$0]=yKeys;removeAxisDelta(box.y,transforms[key$jscomp$0],transforms[scaleKey$jscomp$0],transforms[originKey$jscomp$0],transforms.scale,null===originBox||void 0===originBox?void 0:originBox.y,null===sourceBox||void 0===sourceBox?void 0:sourceBox.y)}function isAxisDeltaZero(delta){return 0===delta.translate&&1===delta.scale}function isDeltaZero(delta){return isAxisDeltaZero(delta.x)&&
isAxisDeltaZero(delta.y)}function boxEquals(a,b){return a.x.min===b.x.min&&a.x.max===b.x.max&&a.y.min===b.y.min&&a.y.max===b.y.max}function aspectRatio(box){return calcLength(box.x)/calcLength(box.y)}function buildProjectionTransform(delta,treeScale,latestTransform){let transform="";const xTranslate=delta.x.translate/treeScale.x,yTranslate=delta.y.translate/treeScale.y;if(xTranslate||yTranslate)transform=`translate3d(${xTranslate}px, ${yTranslate}px, 0) `;if(1!==treeScale.x||1!==treeScale.y)transform+=
`scale(${1/treeScale.x}, ${1/treeScale.y}) `;if(latestTransform){const {rotate,rotateX,rotateY}=latestTransform;rotate&&(transform+=`rotate(${rotate}deg) `);rotateX&&(transform+=`rotateX(${rotateX}deg) `);rotateY&&(transform+=`rotateY(${rotateY}deg) `)}latestTransform=delta.x.scale*treeScale.x;delta=delta.y.scale*treeScale.y;if(1!==latestTransform||1!==delta)transform+=`scale(${latestTransform}, ${delta})`;return transform||"none"}function createProjectionNode($jscomp$destructuring$var95){var {attachResizeListener,
defaultParent,measureScroll,checkIsScrollRoot,resetTransform}=$jscomp$destructuring$var95;return class{constructor(elementId,latestValues,parent){latestValues=void 0===latestValues?{}:latestValues;parent=void 0===parent?null===defaultParent||void 0===defaultParent?void 0:defaultParent():parent;this.id=id$1++;this.animationId=0;this.children=new Set;this.options={};this.shouldResetTransform=this.needsReset=this.isSVG=this.isUpdating=this.updateBlockedByResize=this.updateManuallyBlocked=this.isProjectionDirty=
this.isTransformDirty=this.isLayoutDirty=this.isAnimationBlocked=this.isTreeAnimating=!1;this.treeScale={x:1,y:1};this.eventHandlers=new Map;this.potentialNodes=new Map;this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())};this.updateProjection=()=>{this.nodes.forEach(propagateDirtyNodes);this.nodes.forEach(resolveTargetDelta);this.nodes.forEach(calcProjection)};this.hasProjected=!1;this.isVisible=!0;this.animationProgress=0;this.sharedNodes=new Map;this.elementId=
elementId;this.latestValues=latestValues;this.root=parent?parent.root||parent:this;this.path=parent?[...parent.path,parent]:[];this.depth=(this.parent=parent)?parent.depth+1:0;elementId&&this.root.registerPotentialNode(elementId,this);for(elementId=0;elementId<this.path.length;elementId++)this.path[elementId].shouldResetTransform=!0;this.root===this&&(this.nodes=new FlatTree)}addEventListener(name,handler){this.eventHandlers.has(name)||this.eventHandlers.set(name,new SubscriptionManager);return this.eventHandlers.get(name).add(handler)}notifyListeners(name,
...args){name=this.eventHandlers.get(name);null===name||void 0===name?void 0:name.notify(...args)}hasListeners(name){return this.eventHandlers.has(name)}registerPotentialNode(elementId,node){this.potentialNodes.set(elementId,node)}mount(instance,isLayoutDirty){isLayoutDirty=void 0===isLayoutDirty?!1:isLayoutDirty;var _a$jscomp$0;if(!this.instance){this.isSVG=instance instanceof SVGElement&&"svg"!==instance.tagName;this.instance=instance;var {layoutId,layout,visualElement}=this.options;visualElement&&
!visualElement.current&&visualElement.mount(instance);this.root.nodes.add(this);null===(_a$jscomp$0=this.parent)||void 0===_a$jscomp$0?void 0:_a$jscomp$0.children.add(this);this.elementId&&this.root.potentialNodes.delete(this.elementId);isLayoutDirty&&(layout||layoutId)&&(this.isLayoutDirty=!0);if(attachResizeListener){let cancelDelay;const resizeUnblockUpdate=()=>this.root.updateBlockedByResize=!1;attachResizeListener(instance,()=>{this.root.updateBlockedByResize=!0;cancelDelay&&cancelDelay();cancelDelay=
delay$jscomp$0(resizeUnblockUpdate,250);globalProjectionState.hasAnimatedSinceResize&&(globalProjectionState.hasAnimatedSinceResize=!1,this.nodes.forEach(finishAnimation))})}layoutId&&this.root.registerSharedNode(layoutId,this);!1!==this.options.animate&&visualElement&&(layoutId||layout)&&this.addEventListener("didUpdate",$jscomp$destructuring$var96=>{var {delta,hasLayoutChanged,hasRelativeTargetChanged,layout:newLayout}=$jscomp$destructuring$var96,_a,_b,_c,_d,_e;if(this.isTreeAnimationBlocked())this.relativeTarget=
this.target=void 0;else{$jscomp$destructuring$var96=null!==(_b=null!==(_a=this.options.transition)&&void 0!==_a?_a:visualElement.getDefaultTransition())&&void 0!==_b?_b:defaultLayoutTransition;var {onLayoutAnimationStart,onLayoutAnimationComplete}=visualElement.getProps();_a=!this.targetLayout||!boxEquals(this.targetLayout,newLayout)||hasRelativeTargetChanged;_b=!hasLayoutChanged&&hasRelativeTargetChanged;(null===(_c=this.resumeFrom)||void 0===_c?0:_c.instance)||_b||hasLayoutChanged&&(_a||!this.currentAnimation)?
(this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0),this.setAnimationOrigin(delta,_b),_c=Object.assign({},$jscomp$destructuring$var96.layout||$jscomp$destructuring$var96["default"]||$jscomp$destructuring$var96,{onPlay:onLayoutAnimationStart,onComplete:onLayoutAnimationComplete}),visualElement.shouldReduceMotion&&(_c.delay=0,_c.type=!1),this.startAnimation(_c)):(hasLayoutChanged||0!==this.animationProgress||finishAnimation(this),this.isLead()&&(null===(_e=(_d=
this.options).onExitComplete)||void 0===_e?void 0:_e.call(_d)));this.targetLayout=newLayout}})}}unmount(){var _a,_b;this.options.layoutId&&this.willUpdate();this.root.nodes.remove(this);null===(_a=this.getStack())||void 0===_a?void 0:_a.remove(this);null===(_b=this.parent)||void 0===_b?void 0:_b.children.delete(this);this.instance=void 0;sync.cancelSync.preRender(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||
this.updateBlockedByResize}isTreeAnimationBlocked(){var _a;return this.isAnimationBlocked||(null===(_a=this.parent)||void 0===_a?void 0:_a.isTreeAnimationBlocked())||!1}startUpdate(){var _a;this.isUpdateBlocked()||(this.isUpdating=!0,null===(_a=this.nodes)||void 0===_a?void 0:_a.forEach(resetRotation),this.animationId++)}willUpdate(shouldNotifyListeners){shouldNotifyListeners=void 0===shouldNotifyListeners?!0:shouldNotifyListeners;var _a,_b,_c;if(this.root.isUpdateBlocked())null===(_b=(_a=this.options).onExitComplete)||
void 0===_b?void 0:_b.call(_a);else if(!this.root.isUpdating&&this.root.startUpdate(),!this.isLayoutDirty){this.isLayoutDirty=!0;for(_a=0;_a<this.path.length;_a++)_b=this.path[_a],_b.shouldResetTransform=!0,_b.updateScroll("snapshot");var {layoutId,layout}=this.options;if(void 0!==layoutId||layout)_a=null===(_c=this.options.visualElement)||void 0===_c?void 0:_c.getProps().transformTemplate,this.prevTransformTemplateValue=null===_a||void 0===_a?void 0:_a(this.latestValues,""),this.updateSnapshot(),
shouldNotifyListeners&&this.notifyListeners("willUpdate")}}didUpdate(){this.isUpdateBlocked()?(this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(clearMeasurements)):this.isUpdating&&(this.isUpdating=!1,this.potentialNodes.size&&(this.potentialNodes.forEach(mountNodeEarly),this.potentialNodes.clear()),this.nodes.forEach(resetTransformStyle),this.nodes.forEach(updateLayout),this.nodes.forEach(notifyLayoutUpdate),this.clearAllSnapshots(),sync.flushSync.update(),sync.flushSync.preRender(),
sync.flushSync.render())}clearAllSnapshots(){this.nodes.forEach(clearSnapshot);this.sharedNodes.forEach(removeLeadSnapshots)}scheduleUpdateProjection(){sync__default["default"].preRender(this.updateProjection,!1,!0)}scheduleCheckAfterUnmount(){sync__default["default"].postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){!this.snapshot&&this.instance&&(this.snapshot=this.measure())}updateLayout(){var _a;if(this.instance&&(this.updateScroll(),this.options.alwaysMeasureLayout&&
this.isLead()||this.isLayoutDirty)){if(this.resumeFrom&&!this.resumeFrom.instance)for(var i=0;i<this.path.length;i++)this.path[i].updateScroll();i=this.layout;this.layout=this.measure(!1);this.layoutCorrected=createBox();this.isLayoutDirty=!1;this.projectionDelta=void 0;this.notifyListeners("measure",this.layout.layoutBox);null===(_a=this.options.visualElement)||void 0===_a?void 0:_a.notify("LayoutMeasure",this.layout.layoutBox,null===i||void 0===i?void 0:i.layoutBox)}}updateScroll(phase){phase=void 0===
phase?"measure":phase;let needsMeasurement=!(!this.options.layoutScroll||!this.instance);this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===phase&&(needsMeasurement=!1);needsMeasurement&&(this.scroll={animationId:this.root.animationId,phase,isRoot:checkIsScrollRoot(this.instance),offset:measureScroll(this.instance)})}resetTransform(){var _a;if(resetTransform){var isResetRequested=this.isLayoutDirty||this.shouldResetTransform,hasProjection=this.projectionDelta&&!isDeltaZero(this.projectionDelta),
transformTemplate=null===(_a=this.options.visualElement)||void 0===_a?void 0:_a.getProps().transformTemplate;_a=null===transformTemplate||void 0===transformTemplate?void 0:transformTemplate(this.latestValues,"");transformTemplate=_a!==this.prevTransformTemplateValue;isResetRequested&&(hasProjection||hasTransform(this.latestValues)||transformTemplate)&&(resetTransform(this.instance,_a),this.shouldResetTransform=!1,this.scheduleRender())}}measure(removeTransform){removeTransform=void 0===removeTransform?
!0:removeTransform;const pageBox=this.measurePageBox();let layoutBox=this.removeElementScroll(pageBox);removeTransform&&(layoutBox=this.removeTransform(layoutBox));removeTransform=layoutBox;roundAxis(removeTransform.x);roundAxis(removeTransform.y);return{animationId:this.root.animationId,measuredBox:pageBox,layoutBox,latestValues:{},source:this.id}}measurePageBox(){var {visualElement}=this.options;if(!visualElement)return createBox();visualElement=visualElement.measureViewportBox();const {scroll}=
this.root;scroll&&(translateAxis(visualElement.x,scroll.offset.x),translateAxis(visualElement.y,scroll.offset.y));return visualElement}removeElementScroll(box){const boxWithoutScroll=createBox();copyBoxInto(boxWithoutScroll,box);for(let i=0;i<this.path.length;i++){var node=this.path[i];const {scroll,options}=node;node!==this.root&&scroll&&options.layoutScroll&&(scroll.isRoot&&(copyBoxInto(boxWithoutScroll,box),{scroll:node}=this.root,node&&(translateAxis(boxWithoutScroll.x,-node.offset.x),translateAxis(boxWithoutScroll.y,
-node.offset.y))),translateAxis(boxWithoutScroll.x,scroll.offset.x),translateAxis(boxWithoutScroll.y,scroll.offset.y))}return boxWithoutScroll}applyTransform(box,transformOnly){transformOnly=void 0===transformOnly?!1:transformOnly;const withTransforms=createBox();copyBoxInto(withTransforms,box);for(box=0;box<this.path.length;box++){const node=this.path[box];!transformOnly&&node.options.layoutScroll&&node.scroll&&node!==node.root&&transformBox(withTransforms,{x:-node.scroll.offset.x,y:-node.scroll.offset.y});
hasTransform(node.latestValues)&&transformBox(withTransforms,node.latestValues)}hasTransform(this.latestValues)&&transformBox(withTransforms,this.latestValues);return withTransforms}removeTransform(box){var _a;const boxWithoutTransform=createBox();copyBoxInto(boxWithoutTransform,box);for(box=0;box<this.path.length;box++){const node=this.path[box];if(!node.instance)continue;if(!hasTransform(node.latestValues))continue;hasScale(node.latestValues)&&node.updateSnapshot();const sourceBox=createBox(),nodeBox=
node.measurePageBox();copyBoxInto(sourceBox,nodeBox);removeBoxTransforms(boxWithoutTransform,node.latestValues,null===(_a=node.snapshot)||void 0===_a?void 0:_a.layoutBox,sourceBox)}hasTransform(this.latestValues)&&removeBoxTransforms(boxWithoutTransform,this.latestValues);return boxWithoutTransform}setTargetDelta(delta){this.targetDelta=delta;this.isProjectionDirty=!0;this.root.scheduleUpdateProjection()}setOptions(options){this.options=Object.assign({},this.options,options,{crossfade:void 0!==options.crossfade?
options.crossfade:!0})}clearMeasurements(){this.target=this.targetDelta=this.prevTransformTemplateValue=this.snapshot=this.layout=this.scroll=void 0;this.isLayoutDirty=!1}resolveTargetDelta(){var _a,lead=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=lead.isProjectionDirty);this.isTransformDirty||(this.isTransformDirty=lead.isTransformDirty);if(this.isProjectionDirty||this.attemptToResolveRelativeTarget){var {layout,layoutId}=this.options;if(this.layout&&(layout||layoutId)&&(this.targetDelta||
this.relativeTarget||((lead=this.getClosestProjectingParent())&&lead.layout?(this.relativeParent=lead,this.relativeTarget=createBox(),this.relativeTargetOrigin=createBox(),calcRelativePosition(this.relativeTargetOrigin,this.layout.layoutBox,lead.layout.layoutBox),copyBoxInto(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0),this.relativeTarget||this.targetDelta)){this.target||(this.target=createBox(),this.targetWithTransforms=createBox());if(this.relativeTarget&&
this.relativeTargetOrigin&&(null===(_a=this.relativeParent)||void 0===_a?0:_a.target)){var target=this.target;lead=this.relativeTarget;_a=this.relativeParent.target;var target$jscomp$0=target.x,relative=lead.x;target$jscomp$0.min=_a.x.min+relative.min;target$jscomp$0.max=target$jscomp$0.min+calcLength(relative);target=target.y;lead=lead.y;target.min=_a.y.min+lead.min;target.max=target.min+calcLength(lead)}else this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):
copyBoxInto(this.target,this.layout.layoutBox),applyBoxDelta(this.target,this.targetDelta)):copyBoxInto(this.target,this.layout.layoutBox);this.attemptToResolveRelativeTarget&&(this.attemptToResolveRelativeTarget=!1,(_a=this.getClosestProjectingParent())&&!!_a.resumingFrom===!!this.resumingFrom&&!_a.options.layoutScroll&&_a.target?(this.relativeParent=_a,this.relativeTarget=createBox(),this.relativeTargetOrigin=createBox(),calcRelativePosition(this.relativeTargetOrigin,this.target,_a.target),copyBoxInto(this.relativeTarget,
this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0)}}}getClosestProjectingParent(){if(this.parent&&!hasScale(this.parent.latestValues)&&!has2DTranslate(this.parent.latestValues))return(this.parent.relativeTarget||this.parent.targetDelta)&&this.parent.layout?this.parent:this.parent.getClosestProjectingParent()}calcProjection(){var _a;const {isProjectionDirty,isTransformDirty}=this;this.isProjectionDirty=this.isTransformDirty=!1;var lead=this.getLead(),isShared=!!this.resumingFrom||
this!==lead,canSkip=!0;isProjectionDirty&&(canSkip=!1);isShared&&isTransformDirty&&(canSkip=!1);if(!canSkip){var {layout,layoutId}=this.options;this.isTreeAnimating=!!((null===(_a=this.parent)||void 0===_a?0:_a.isTreeAnimating)||this.currentAnimation||this.pendingAnimation);this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0);if(this.layout&&(layout||layoutId)){copyBoxInto(this.layoutCorrected,this.layout.layoutBox);{_a=this.layoutCorrected;canSkip=this.treeScale;var treePath=this.path;
isShared=void 0===isShared?!1:isShared;var _a$jscomp$0,_b;const treeLength=treePath.length;if(treeLength){canSkip.x=canSkip.y=1;for(let i=0;i<treeLength;i++){var node=treePath[i];var delta=node.projectionDelta;"contents"!==(null===(_b=null===(_a$jscomp$0=node.instance)||void 0===_a$jscomp$0?void 0:_a$jscomp$0.style)||void 0===_b?void 0:_b.display)&&(isShared&&node.options.layoutScroll&&node.scroll&&node!==node.root&&transformBox(_a,{x:-node.scroll.offset.x,y:-node.scroll.offset.y}),delta&&(canSkip.x*=
delta.x.scale,canSkip.y*=delta.y.scale,applyBoxDelta(_a,delta)),isShared&&hasTransform(node.latestValues)&&transformBox(_a,node.latestValues))}canSkip.x=snapToDefault(canSkip.x);canSkip.y=snapToDefault(canSkip.y)}}({target:lead}=lead);lead&&(this.projectionDelta||(this.projectionDelta={x:createAxisDelta(),y:createAxisDelta()},this.projectionDeltaWithTransform={x:createAxisDelta(),y:createAxisDelta()}),_a$jscomp$0=this.treeScale.x,_b=this.treeScale.y,_a=this.projectionTransform,calcBoxDelta(this.projectionDelta,
this.layoutCorrected,lead,this.latestValues),this.projectionTransform=buildProjectionTransform(this.projectionDelta,this.treeScale),this.projectionTransform!==_a||this.treeScale.x!==_a$jscomp$0||this.treeScale.y!==_b)&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",lead))}}}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(notifyAll){notifyAll=void 0===notifyAll?!0:notifyAll;var _a,_b,_c;null===(_b=(_a=this.options).scheduleRender)||void 0===_b?
void 0:_b.call(_a);notifyAll&&(null===(_c=this.getStack())||void 0===_c?void 0:_c.scheduleRender());this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}setAnimationOrigin(delta,hasOnlyRelativeTargetChanged){hasOnlyRelativeTargetChanged=void 0===hasOnlyRelativeTargetChanged?!1:hasOnlyRelativeTargetChanged;var _a$jscomp$1,_b$jscomp$0;const snapshot=this.snapshot,snapshotLatestValues=(null===snapshot||void 0===snapshot?void 0:snapshot.latestValues)||{},mixedValues=Object.assign({},
this.latestValues),targetDelta={x:createAxisDelta(),y:createAxisDelta()};this.relativeTarget=this.relativeTargetOrigin=void 0;this.attemptToResolveRelativeTarget=!hasOnlyRelativeTargetChanged;const relativeLayout=createBox(),isSharedLayoutAnimation=(null===snapshot||void 0===snapshot?void 0:snapshot.source)!==(null===(_a$jscomp$1=this.layout)||void 0===_a$jscomp$1?void 0:_a$jscomp$1.source),isOnlyMember=1>=((null===(_b$jscomp$0=this.getStack())||void 0===_b$jscomp$0?void 0:_b$jscomp$0.members.length)||
0),shouldCrossfadeOpacity=!(!isSharedLayoutAnimation||isOnlyMember||!0!==this.options.crossfade||this.path.some(hasOpacityCrossfade));this.animationProgress=0;this.mixTargetDelta=latest=>{var _a;latest/=1E3;mixAxisDelta(targetDelta.x,delta.x,latest);mixAxisDelta(targetDelta.y,delta.y,latest);this.setTargetDelta(targetDelta);if(this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&(null===(_a=this.relativeParent)||void 0===_a?0:_a.layout)){calcRelativePosition(relativeLayout,this.layout.layoutBox,
this.relativeParent.layout.layoutBox);var output=this.relativeTarget;_a=this.relativeTargetOrigin;var output$jscomp$0=output.x,from=_a.x,to=relativeLayout.x;output$jscomp$0.min=mix(from.min,to.min,latest);output$jscomp$0.max=mix(from.max,to.max,latest);output=output.y;_a=_a.y;output$jscomp$0=relativeLayout.y;output.min=mix(_a.min,output$jscomp$0.min,latest);output.max=mix(_a.max,output$jscomp$0.max,latest)}if(isSharedLayoutAnimation){this.animationValues=mixedValues;_a=this.latestValues;var _a$jscomp$0,
_b,_c,_d;shouldCrossfadeOpacity?(mixedValues.opacity=mix(0,null!==(_a$jscomp$0=_a.opacity)&&void 0!==_a$jscomp$0?_a$jscomp$0:1,easeCrossfadeIn(latest)),mixedValues.opacityExit=mix(null!==(_b=snapshotLatestValues.opacity)&&void 0!==_b?_b:1,0,easeCrossfadeOut(latest))):isOnlyMember&&(mixedValues.opacity=mix(null!==(_c=snapshotLatestValues.opacity)&&void 0!==_c?_c:1,null!==(_d=_a.opacity)&&void 0!==_d?_d:1,latest));for(_a$jscomp$0=0;_a$jscomp$0<numBorders;_a$jscomp$0++)if(_b=`border${borders[_a$jscomp$0]}Radius`,
_c=getRadius(snapshotLatestValues,_b),_d=getRadius(_a,_b),void 0!==_c||void 0!==_d)if(_c||(_c=0),_d||(_d=0),0===_c||0===_d||("number"===typeof _c||styleValueTypes.px.test(_c))===("number"===typeof _d||styleValueTypes.px.test(_d))){if(mixedValues[_b]=Math.max(mix(asNumber(_c),asNumber(_d),latest),0),styleValueTypes.percent.test(_d)||styleValueTypes.percent.test(_c))mixedValues[_b]+="%"}else mixedValues[_b]=_d;if(snapshotLatestValues.rotate||_a.rotate)mixedValues.rotate=mix(snapshotLatestValues.rotate||
0,_a.rotate||0,latest)}this.root.scheduleUpdateProjection();this.scheduleRender();this.animationProgress=latest};this.mixTargetDelta(0)}startAnimation(options){var _a$jscomp$0,_b;this.notifyListeners("animationStart");null===(_a$jscomp$0=this.currentAnimation)||void 0===_a$jscomp$0?void 0:_a$jscomp$0.stop();this.resumingFrom&&(null===(_b=this.resumingFrom.currentAnimation)||void 0===_b?void 0:_b.stop());this.pendingAnimation&&(sync.cancelSync.update(this.pendingAnimation),this.pendingAnimation=void 0);
this.pendingAnimation=sync__default["default"].update(()=>{globalProjectionState.hasAnimatedSinceResize=!0;this.currentAnimation=animate$jscomp$0(0,1E3,Object.assign({},options,{onUpdate:latest=>{var _a;this.mixTargetDelta(latest);null===(_a=options.onUpdate)||void 0===_a?void 0:_a.call(options,latest)},onComplete:()=>{var _a;null===(_a=options.onComplete)||void 0===_a?void 0:_a.call(options);this.completeAnimation()}}));this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation);
this.pendingAnimation=void 0})}completeAnimation(){var _a;this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);null===(_a=this.getStack())||void 0===_a?void 0:_a.exitAnimationComplete();this.resumingFrom=this.currentAnimation=this.animationValues=void 0;this.notifyListeners("animationComplete")}finishAnimation(){var _a;this.currentAnimation&&(null===(_a=this.mixTargetDelta)||void 0===_a?void 0:_a.call(this,1E3),this.currentAnimation.stop());this.completeAnimation()}applyTransformsToTarget(){const lead=
this.getLead();let {targetWithTransforms,target,layout,latestValues}=lead;if(targetWithTransforms&&target&&layout){if(this!==lead&&this.layout&&layout&&shouldAnimatePositionOnly(this.options.animationType,this.layout.layoutBox,layout.layoutBox)){target=this.target||createBox();var xLength=calcLength(this.layout.layoutBox.x);target.x.min=lead.target.x.min;target.x.max=target.x.min+xLength;xLength=calcLength(this.layout.layoutBox.y);target.y.min=lead.target.y.min;target.y.max=target.y.min+xLength}copyBoxInto(targetWithTransforms,
target);transformBox(targetWithTransforms,latestValues);calcBoxDelta(this.projectionDeltaWithTransform,this.layoutCorrected,targetWithTransforms,latestValues)}}registerSharedNode(layoutId,node){var _a,_b,_c;this.sharedNodes.has(layoutId)||this.sharedNodes.set(layoutId,new NodeStack);this.sharedNodes.get(layoutId).add(node);node.promote({transition:null===(_a=node.options.initialPromotionConfig)||void 0===_a?void 0:_a.transition,preserveFollowOpacity:null===(_c=null===(_b=node.options.initialPromotionConfig)||
void 0===_b?void 0:_b.shouldPreserveFollowOpacity)||void 0===_c?void 0:_c.call(_b,node)})}isLead(){const stack=this.getStack();return stack?stack.lead===this:!0}getLead(){var _a;const {layoutId}=this.options;return layoutId?(null===(_a=this.getStack())||void 0===_a?void 0:_a.lead)||this:this}getPrevLead(){var _a;const {layoutId}=this.options;return layoutId?null===(_a=this.getStack())||void 0===_a?void 0:_a.prevLead:void 0}getStack(){const {layoutId}=this.options;if(layoutId)return this.root.sharedNodes.get(layoutId)}promote($jscomp$destructuring$var97){var {needsReset,
transition,preserveFollowOpacity}=void 0===$jscomp$destructuring$var97?{}:$jscomp$destructuring$var97;($jscomp$destructuring$var97=this.getStack())&&$jscomp$destructuring$var97.promote(this,preserveFollowOpacity);needsReset&&(this.projectionDelta=void 0,this.needsReset=!0);transition&&this.setOptions({transition})}relegate(){const stack=this.getStack();return stack?stack.relegate(this):!1}resetRotation(){const {visualElement}=this.options;if(visualElement){var hasRotate=!1,{latestValues}=visualElement;
if(latestValues.rotate||latestValues.rotateX||latestValues.rotateY||latestValues.rotateZ)hasRotate=!0;if(hasRotate){hasRotate={};for(let i=0;i<transformAxes.length;i++){const key="rotate"+transformAxes[i];latestValues[key]&&(hasRotate[key]=latestValues[key],visualElement.setStaticValue(key,0))}null===visualElement||void 0===visualElement?void 0:visualElement.render();for(const key in hasRotate)visualElement.setStaticValue(key,hasRotate[key]);visualElement.scheduleRender()}}}getProjectionStyles(styleProp){styleProp=
void 0===styleProp?{}:styleProp;var _a,_b,_c,styles={};if(!this.instance||this.isSVG)return styles;if(this.isVisible)styles.visibility="";else return{visibility:"hidden"};var transformTemplate=null===(_a=this.options.visualElement)||void 0===_a?void 0:_a.getProps().transformTemplate;if(this.needsReset)return this.needsReset=!1,styles.opacity="",styles.pointerEvents=resolveMotionValue(styleProp.pointerEvents)||"",styles.transform=transformTemplate?transformTemplate(this.latestValues,""):"none",styles;
_a=this.getLead();if(!this.projectionDelta||!this.layout||!_a.target)return styles={},this.options.layoutId&&(styles.opacity=void 0!==this.latestValues.opacity?this.latestValues.opacity:1,styles.pointerEvents=resolveMotionValue(styleProp.pointerEvents)||""),this.hasProjected&&!hasTransform(this.latestValues)&&(styles.transform=transformTemplate?transformTemplate({},""):"none",this.hasProjected=!1),styles;const valuesToRender=_a.animationValues||_a.latestValues;this.applyTransformsToTarget();styles.transform=
buildProjectionTransform(this.projectionDeltaWithTransform,this.treeScale,valuesToRender);transformTemplate&&(styles.transform=transformTemplate(valuesToRender,styles.transform));const {x,y}=this.projectionDelta;styles.transformOrigin=`${100*x.origin}% ${100*y.origin}% 0`;styles.opacity=_a.animationValues?_a===this?null!==(_c=null!==(_b=valuesToRender.opacity)&&void 0!==_b?_b:this.latestValues.opacity)&&void 0!==_c?_c:1:this.preserveOpacity?this.latestValues.opacity:valuesToRender.opacityExit:_a===
this?void 0!==valuesToRender.opacity?valuesToRender.opacity:"":void 0!==valuesToRender.opacityExit?valuesToRender.opacityExit:0;for(const key in scaleCorrectors){if(void 0===valuesToRender[key])continue;const {correct,applyTo}=scaleCorrectors[key];transformTemplate=correct(valuesToRender[key],_a);if(applyTo)for(_b=applyTo.length,_c=0;_c<_b;_c++)styles[applyTo[_c]]=transformTemplate;else styles[key]=transformTemplate}this.options.layoutId&&(styles.pointerEvents=_a===this?resolveMotionValue(styleProp.pointerEvents)||
"":"none");return styles}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(node=>{var _a;return null===(_a=node.currentAnimation)||void 0===_a?void 0:_a.stop()});this.root.nodes.forEach(clearMeasurements);this.root.sharedNodes.clear()}}}function updateLayout(node){node.updateLayout()}function notifyLayoutUpdate(node){var _a;const snapshot=(null===(_a=node.resumeFrom)||void 0===_a?void 0:_a.snapshot)||node.snapshot;if(node.isLead()&&node.layout&&snapshot&&node.hasListeners("didUpdate")){const {layoutBox:layout,
measuredBox:measuredLayout}=node.layout;({animationType:_a}=node.options);const isShared=snapshot.source!==node.layout.source;"size"===_a?eachAxis(axis=>{const axisSnapshot=isShared?snapshot.measuredBox[axis]:snapshot.layoutBox[axis],length=calcLength(axisSnapshot);axisSnapshot.min=layout[axis].min;axisSnapshot.max=axisSnapshot.min+length}):shouldAnimatePositionOnly(_a,snapshot.layoutBox,layout)&&eachAxis(axis=>{const axisSnapshot=isShared?snapshot.measuredBox[axis]:snapshot.layoutBox[axis];axis=
calcLength(layout[axis]);axisSnapshot.max=axisSnapshot.min+axis});_a={x:createAxisDelta(),y:createAxisDelta()};calcBoxDelta(_a,layout,snapshot.layoutBox);var _b={x:createAxisDelta(),y:createAxisDelta()};isShared?calcBoxDelta(_b,node.applyTransform(measuredLayout,!0),snapshot.measuredBox):calcBoxDelta(_b,layout,snapshot.layoutBox);var _c=!isDeltaZero(_a);let hasRelativeTargetChanged=!1;if(!node.resumeFrom){var relativeParent=node.getClosestProjectingParent();if(relativeParent&&!relativeParent.resumeFrom){const {snapshot:parentSnapshot,
layout:parentLayout}=relativeParent;if(parentSnapshot&&parentLayout){relativeParent=createBox();calcRelativePosition(relativeParent,snapshot.layoutBox,parentSnapshot.layoutBox);const relativeLayout=createBox();calcRelativePosition(relativeLayout,layout,parentLayout.layoutBox);boxEquals(relativeParent,relativeLayout)||(hasRelativeTargetChanged=!0)}}}node.notifyListeners("didUpdate",{layout,snapshot,delta:_b,layoutDelta:_a,hasLayoutChanged:_c,hasRelativeTargetChanged})}else node.isLead()&&(null===(_c=
(_b=node.options).onExitComplete)||void 0===_c?void 0:_c.call(_b));node.options.transition=void 0}function propagateDirtyNodes(node){node.isProjectionDirty||(node.isProjectionDirty=!(!node.parent||!node.parent.isProjectionDirty));node.isTransformDirty||(node.isTransformDirty=!(!node.parent||!node.parent.isTransformDirty))}function clearSnapshot(node){node.clearSnapshot()}function clearMeasurements(node){node.clearMeasurements()}function resetTransformStyle(node){const {visualElement}=node.options;
(null===visualElement||void 0===visualElement?0:visualElement.getProps().onBeforeLayoutMeasure)&&visualElement.notify("BeforeLayoutMeasure");node.resetTransform()}function finishAnimation(node){node.finishAnimation();node.targetDelta=node.relativeTarget=node.target=void 0}function resolveTargetDelta(node){node.resolveTargetDelta()}function calcProjection(node){node.calcProjection()}function resetRotation(node){node.resetRotation()}function removeLeadSnapshots(stack){stack.removeLeadSnapshot()}function mixAxisDelta(output,
delta,p){output.translate=mix(delta.translate,0,p);output.scale=mix(delta.scale,1,p);output.origin=delta.origin;output.originPoint=delta.originPoint}function hasOpacityCrossfade(node){return node.animationValues&&void 0!==node.animationValues.opacityExit}function mountNodeEarly(node,elementId){let searchNode=node.root;for(let i=node.path.length-1;0<=i;i--)if(node.path[i].instance){searchNode=node.path[i];break}(elementId=(searchNode&&searchNode!==node.root?searchNode.instance:document).querySelector(`[data-projection-id="${elementId}"]`))&&
node.mount(elementId,!0)}function roundAxis(axis){axis.min=Math.round(axis.min);axis.max=Math.round(axis.max)}function shouldAnimatePositionOnly(animationType,snapshot,layout){return"position"===animationType||"preserve-aspect"===animationType&&!isNear(aspectRatio(snapshot),aspectRatio(layout),.2)}function useIsMounted(){const isMounted=React.useRef(!1);useIsomorphicLayoutEffect(()=>{isMounted.current=!0;return()=>{isMounted.current=!1}},[]);return isMounted}function useForceUpdate(){const isMounted=
useIsMounted(),[forcedRenderCount,setForcedRenderCount]=React.useState(0),forceRender=React.useCallback(()=>{isMounted.current&&setForcedRenderCount(forcedRenderCount+1)},[forcedRenderCount]);return[React.useCallback(()=>sync__default["default"].postRender(forceRender),[forceRender]),forcedRenderCount]}function PopChild($jscomp$destructuring$var98){var {children,isPresent}=$jscomp$destructuring$var98;const id=React.useId(),ref=React.useRef(null),size=React.useRef({width:0,height:0,top:0,left:0});
React.useInsertionEffect(()=>{const {width,height,top,left}=size.current;if(!isPresent&&ref.current&&width&&height){ref.current.dataset.motionPopId=id;var style=document.createElement("style");document.head.appendChild(style);style.sheet&&style.sheet.insertRule(`
          [data-motion-pop-id="${id}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `);return()=>{document.head.removeChild(style)}}},[isPresent]);return React__namespace.createElement(PopChildMeasure,{isPresent,childRef:ref,sizeRef:size},React__namespace.cloneElement(children,{ref}))}function newChildrenMap(){return new Map}function updateChildLookup(children,allChildren){children.forEach(child=>{allChildren.set(child.key||"",child)})}function onlyElements(children){const filtered=[];React.Children.forEach(children,child=>{React.isValidElement(child)&&filtered.push(child)});
return filtered}function nodeGroup(){const nodes=new Set,subscriptions=new WeakMap,dirtyAll=()=>nodes.forEach(notify);return{add:node=>{nodes.add(node);subscriptions.set(node,node.addEventListener("willUpdate",dirtyAll))},remove:node=>{var _a;nodes.delete(node);null===(_a=subscriptions.get(node))||void 0===_a?void 0:_a();subscriptions.delete(node);nodes.forEach(notify)},dirty:dirtyAll}}function isLazyBundle(features){return"function"===typeof features}function checkReorder(order,value,offset,velocity){if(!velocity)return order;
const index=order.findIndex(item=>item.value===value);if(-1===index)return order;velocity=0<velocity?1:-1;var nextItem=order[index+velocity];if(!nextItem)return order;const item$jscomp$0=order[index];nextItem=nextItem.layout;nextItem=mix(nextItem.min,nextItem.max,.5);return 1===velocity&&item$jscomp$0.layout.max+offset>nextItem||-1===velocity&&item$jscomp$0.layout.min+offset<nextItem?moveItem(order,index,index+velocity):order}function getValue(item){return item.value}function compareMin(a,b){return a.layout.min-
b.layout.min}function useMotionValue(initial){const value=useConstant(()=>motionValue$jscomp$0(initial)),{isStatic}=React.useContext(MotionConfigContext);if(isStatic){const [,setLatest]=React.useState(initial);React.useEffect(()=>value.onChange(setLatest),[])}return value}function transform$jscomp$0(...args){const useImmediate=!Array.isArray(args[0]),argOffset=useImmediate?0:-1,inputValue=args[0+argOffset],outputRange=args[2+argOffset];var JSCompiler_temp_const=Object,v=outputRange[0];args=interpolate(args[1+
argOffset],outputRange,JSCompiler_temp_const.assign.call(JSCompiler_temp_const,{},{mixer:"object"===typeof v&&v.mix?v.mix:void 0},args[3+argOffset]));return useImmediate?args(inputValue):args}function useOnChange(value,callback){useIsomorphicLayoutEffect(()=>{if(isMotionValue(value))return callback(value.get()),value.onChange(callback)},[value,callback])}function useMultiOnChange(values,handler,cleanup){useIsomorphicLayoutEffect(()=>{const subscriptions=values.map(value=>value.onChange(handler));
return()=>{subscriptions.forEach(unsubscribe=>unsubscribe());cleanup()}})}function useCombineMotionValues(values,combineValues){const value=useMotionValue(combineValues()),updateValue=()=>value.set(combineValues());value.set(combineValues());useMultiOnChange(values,()=>sync__default["default"].update(updateValue,!1,!0),()=>sync.cancelSync.update(updateValue));return value}function useTransform(input,inputRangeOrTransformer,outputRange,options){const transformer="function"===typeof inputRangeOrTransformer?
inputRangeOrTransformer:transform$jscomp$0(inputRangeOrTransformer,outputRange,options);return Array.isArray(input)?useListTransform(input,transformer):useListTransform([input],$jscomp$destructuring$var115=>{[$jscomp$destructuring$var115]=$jscomp$destructuring$var115;return transformer($jscomp$destructuring$var115)})}function useListTransform(values,transformer){const latest=useConstant(()=>[]);return useCombineMotionValues(values,()=>{latest.length=0;const numValues=values.length;for(let i=0;i<numValues;i++)latest[i]=
values[i].get();return transformer(latest)})}function useDefaultMotionValue(value,defaultValue){defaultValue=void 0===defaultValue?0:defaultValue;return isMotionValue(value)?value:useMotionValue(defaultValue)}function useScroll($jscomp$destructuring$var120){var $jscomp$destructuring$var121=void 0===$jscomp$destructuring$var120?{}:$jscomp$destructuring$var120;$jscomp$destructuring$var120=Object.assign({},$jscomp$destructuring$var121);var container=$jscomp$destructuring$var121.container,target=$jscomp$destructuring$var121.target;
$jscomp$destructuring$var121=void 0===$jscomp$destructuring$var121.layoutEffect?!0:$jscomp$destructuring$var121.layoutEffect;var options=(delete $jscomp$destructuring$var120.container,delete $jscomp$destructuring$var120.target,delete $jscomp$destructuring$var120.layoutEffect,$jscomp$destructuring$var120);const values=useConstant(createScrollMotionValues);($jscomp$destructuring$var121?useIsomorphicLayoutEffect:React.useEffect)(()=>dom.scroll($jscomp$destructuring$var123=>{var {x,y}=$jscomp$destructuring$var123;
values.scrollX.set(x.current);values.scrollXProgress.set(x.progress);values.scrollY.set(y.current);values.scrollYProgress.set(y.progress)},Object.assign({},options,{container:(null===container||void 0===container?void 0:container.current)||void 0,target:(null===target||void 0===target?void 0:target.current)||void 0})),[]);return values}function useAnimationFrame(callback){const initialTimestamp=React.useRef(0),{isStatic}=React.useContext(MotionConfigContext);React.useEffect(()=>{if(!isStatic){var provideTimeSinceStart=
$jscomp$destructuring$var124=>{var {timestamp,delta}=$jscomp$destructuring$var124;initialTimestamp.current||(initialTimestamp.current=timestamp);callback(timestamp-initialTimestamp.current,delta)};sync__default["default"].update(provideTimeSinceStart,!0);return()=>sync.cancelSync.update(provideTimeSinceStart)}},[callback])}function useReducedMotion(){!JSCompiler_object_inline_current_5836&&initPrefersReducedMotion();const [shouldReduceMotion]=React.useState(JSCompiler_object_inline_current_5835);
return shouldReduceMotion}function animationControls(){let hasMounted=!1;const pendingAnimations=[],subscribers=new Set,controls={subscribe(visualElement){subscribers.add(visualElement);return()=>void subscribers.delete(visualElement)},start(definition,transitionOverride){if(hasMounted){const animations=[];subscribers.forEach(visualElement=>{animations.push(animateVisualElement(visualElement,definition,{transitionOverride}))});return Promise.all(animations)}return new Promise(resolve=>{pendingAnimations.push({animation:[definition,
transitionOverride],resolve})})},set(definition){heyListen.invariant(hasMounted,"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.");return subscribers.forEach(visualElement=>{Array.isArray(definition)?setVariants(visualElement,definition):"string"===typeof definition?setVariants(visualElement,[definition]):setTarget(visualElement,definition)})},stop(){subscribers.forEach(visualElement=>{stopAnimation(visualElement)})},mount(){hasMounted=
!0;pendingAnimations.forEach($jscomp$destructuring$var125=>{var {animation,resolve}=$jscomp$destructuring$var125;controls.start(...animation).then(resolve)});return()=>{hasMounted=!1;controls.stop()}}};return controls}function useAnimationControls(){const controls=useConstant(animationControls);React.useEffect(controls.mount,[]);return controls}function isMotionComponent(component){return null!==component&&"object"===typeof component&&motionComponentSymbol in component}function startTransition(callback){rootProjectionNode.current&&
(rootProjectionNode.current.isUpdating=!1,rootProjectionNode.current.blockUpdate(),callback&&callback())}var process=require("module$node_modules$process$browser");"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var React=require("module$node_modules$react$index"),styleValueTypes=require("module$node_modules$style_value_types$dist$valueTypes_cjs"),heyListen=require("module$node_modules$hey_listen$dist$index"),sync=require("module$node_modules$framesync$dist$framesync_cjs"),dom=
require("module$node_modules$$motionone$dom$dist$index_cjs"),React__default=_interopDefaultLegacy(React),React__namespace=function(e){if(e&&e.__esModule)return e;var n=Object.create(null);e&&Object.keys(e).forEach(function(k){if("default"!==k){var d=Object.getOwnPropertyDescriptor(e,k);Object.defineProperty(n,k,d.get?d:{enumerable:!0,get:function(){return e[k]}})}});n["default"]=e;return Object.freeze(n)}(React),sync__default=_interopDefaultLegacy(sync);const MotionConfigContext=React.createContext({transformPagePoint:p=>
p,isStatic:!1,reducedMotion:"never"}),MotionContext=React.createContext({}),PresenceContext=React.createContext(null),isBrowser="undefined"!==typeof document,useIsomorphicLayoutEffect=isBrowser?React.useLayoutEffect:React.useEffect,LazyContext=React.createContext({strict:!1}),variantProps$1="initial animate exit whileHover whileDrag whileTap whileFocus whileInView".split(" "),createDefinition=propNames=>({isEnabled:props=>propNames.some(name=>!!props[name])}),featureDefinitions={measureLayout:createDefinition(["layout",
"layoutId","drag"]),animation:createDefinition("animate exit variants whileHover whileTap whileFocus whileDrag whileInView".split(" ")),exit:createDefinition(["exit"]),drag:createDefinition(["drag","dragControls"]),focus:createDefinition(["whileFocus"]),hover:createDefinition(["whileHover","onHoverStart","onHoverEnd"]),tap:createDefinition(["whileTap","onTap","onTapStart","onTapCancel"]),pan:createDefinition(["onPan","onPanStart","onPanSessionStart","onPanEnd"]),inView:createDefinition(["whileInView",
"onViewportEnter","onViewportLeave"])},globalProjectionState={hasAnimatedSinceResize:!0,hasEverUpdated:!1};let id$2=1;const LayoutGroupContext=React.createContext({});class VisualElementHandler extends React__default["default"].Component{getSnapshotBeforeUpdate(){const {visualElement,props}=this.props;visualElement&&visualElement.setProps(props);return null}componentDidUpdate(){}render(){return this.props.children}}const SwitchLayoutGroupContext=React.createContext({}),motionComponentSymbol=Symbol.for("motionComponentSymbol"),
lowercaseSVGElements="animate circle defs desc ellipse g image line filter marker mask metadata path pattern polygon polyline rect stop switch symbol svg text tspan use view".split(" "),scaleCorrectors={},transformPropOrder="transformPerspective x y z translateX translateY translateZ scale scaleX scaleY rotate rotateX rotateY rotateZ skew skewX skewY".split(" "),transformProps=new Set(transformPropOrder),isMotionValue=value=>!(null===value||void 0===value||!value.getVelocity),translateAlias={x:"translateX",
y:"translateY",z:"translateZ",transformPerspective:"perspective"},sortTransformProps=(a,b)=>transformPropOrder.indexOf(a)-transformPropOrder.indexOf(b),int=Object.assign({},styleValueTypes.number,{transform:Math.round}),numberValueTypes={borderWidth:styleValueTypes.px,borderTopWidth:styleValueTypes.px,borderRightWidth:styleValueTypes.px,borderBottomWidth:styleValueTypes.px,borderLeftWidth:styleValueTypes.px,borderRadius:styleValueTypes.px,radius:styleValueTypes.px,borderTopLeftRadius:styleValueTypes.px,
borderTopRightRadius:styleValueTypes.px,borderBottomRightRadius:styleValueTypes.px,borderBottomLeftRadius:styleValueTypes.px,width:styleValueTypes.px,maxWidth:styleValueTypes.px,height:styleValueTypes.px,maxHeight:styleValueTypes.px,size:styleValueTypes.px,top:styleValueTypes.px,right:styleValueTypes.px,bottom:styleValueTypes.px,left:styleValueTypes.px,padding:styleValueTypes.px,paddingTop:styleValueTypes.px,paddingRight:styleValueTypes.px,paddingBottom:styleValueTypes.px,paddingLeft:styleValueTypes.px,
margin:styleValueTypes.px,marginTop:styleValueTypes.px,marginRight:styleValueTypes.px,marginBottom:styleValueTypes.px,marginLeft:styleValueTypes.px,rotate:styleValueTypes.degrees,rotateX:styleValueTypes.degrees,rotateY:styleValueTypes.degrees,rotateZ:styleValueTypes.degrees,scale:styleValueTypes.scale,scaleX:styleValueTypes.scale,scaleY:styleValueTypes.scale,scaleZ:styleValueTypes.scale,skew:styleValueTypes.degrees,skewX:styleValueTypes.degrees,skewY:styleValueTypes.degrees,distance:styleValueTypes.px,
translateX:styleValueTypes.px,translateY:styleValueTypes.px,translateZ:styleValueTypes.px,x:styleValueTypes.px,y:styleValueTypes.px,z:styleValueTypes.px,perspective:styleValueTypes.px,transformPerspective:styleValueTypes.px,opacity:styleValueTypes.alpha,originX:styleValueTypes.progressPercentage,originY:styleValueTypes.progressPercentage,originZ:styleValueTypes.px,zIndex:int,fillOpacity:styleValueTypes.alpha,strokeOpacity:styleValueTypes.alpha,numOctaves:int},createHtmlRenderState=()=>({style:{},
transform:{},transformKeys:[],transformOrigin:{},vars:{}}),validMotionProps=new Set("initial style values variants transition transformTemplate transformValues custom inherit layout layoutId layoutDependency onLayoutAnimationStart onLayoutAnimationComplete onLayoutMeasure onBeforeLayoutMeasure onAnimationStart onAnimationComplete onUpdate onDragStart onDrag onDragEnd onMeasureDragConstraints onDirectionLock onDragTransitionEnd drag dragControls dragListener dragConstraints dragDirectionLock dragSnapToOrigin _dragX _dragY dragElastic dragMomentum dragPropagation dragTransition onHoverStart onHoverEnd layoutScroll whileInView onViewportEnter onViewportLeave viewport whileTap onTap onTapStart onTapCancel animate exit variants whileHover whileTap whileFocus whileDrag whileInView onPan onPanStart onPanSessionStart onPanEnd".split(" "));
let shouldForward=key=>!isValidMotionProp(key);try{loadExternalIsValidProp(require("module$node_modules$$emotion$is_prop_valid$dist$is_prop_valid_browser_cjs").default)}catch(_a){}const camelKeys={offset:"strokeDashoffset",array:"strokeDasharray"},createSvgRenderState=()=>Object.assign({},createHtmlRenderState(),{attrs:{}}),isSVGTag=tag=>"string"===typeof tag&&"svg"===tag.toLowerCase(),camelToDash=str=>str.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),camelCaseAttributes=new Set("baseFrequency diffuseConstant kernelMatrix kernelUnitLength keySplines keyTimes limitingConeAngle markerHeight markerWidth numOctaves targetX targetY surfaceScale specularConstant specularExponent stdDeviation tableValues viewBox gradientTransform pathLength".split(" ")),
resolveFinalValueInKeyframes=v=>Array.isArray(v)?v[v.length-1]||0:v,makeUseVisualState=config=>(props,isStatic)=>{const context=React.useContext(MotionContext),presenceContext=React.useContext(PresenceContext),make=()=>makeState(config,props,context,presenceContext);return isStatic?make():useConstant(make)},svgMotionConfig={useVisualState:makeUseVisualState({scrapeMotionValuesFromProps,createRenderState:createSvgRenderState,onMount:(props,instance,$jscomp$destructuring$var14)=>{var {renderState,latestValues}=
$jscomp$destructuring$var14;try{renderState.dimensions="function"===typeof instance.getBBox?instance.getBBox():instance.getBoundingClientRect()}catch(e){renderState.dimensions={x:0,y:0,width:0,height:0}}buildSVGAttrs(renderState,latestValues,{enableHardwareAcceleration:!1},isSVGTag(instance.tagName),props.transformTemplate);renderSVG(instance,renderState)}})},htmlMotionConfig={useVisualState:makeUseVisualState({scrapeMotionValuesFromProps:scrapeMotionValuesFromProps$1,createRenderState:createHtmlRenderState})};
exports.AnimationType=void 0;(function(AnimationType){AnimationType.Animate="animate";AnimationType.Hover="whileHover";AnimationType.Tap="whileTap";AnimationType.Drag="whileDrag";AnimationType.Focus="whileFocus";AnimationType.InView="whileInView";AnimationType.Exit="exit"})(exports.AnimationType||(exports.AnimationType={}));const defaultPagePoint={pageX:0,pageY:0},wrapHandler=(handler,shouldFilterPrimaryPointer)=>{const listener=event=>handler(event,extractEventInfo(event));return(void 0===shouldFilterPrimaryPointer?
0:shouldFilterPrimaryPointer)?filterPrimaryPointer(listener):listener},mouseEventNames={pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointercancel:"mousecancel",pointerover:"mouseover",pointerout:"mouseout",pointerenter:"mouseenter",pointerleave:"mouseleave"},touchEventNames={pointerdown:"touchstart",pointermove:"touchmove",pointerup:"touchend",pointercancel:"touchcancel"},globalHorizontalLock=createLock("dragHorizontal"),globalVerticalLock=createLock("dragVertical"),isNodeOrChild=
(parent,child)=>child?parent===child?!0:isNodeOrChild(parent,child.parentElement):!1,combineFunctions=(a,b)=>v=>b(a(v)),env="undefined"===typeof process||void 0===process.env?"production":"development",warned=new Set,observerCallbacks=new WeakMap,observers=new WeakMap,fireObserverCallback=entry=>{const callback=observerCallbacks.get(entry.target);callback&&callback(entry)},fireAllObserverCallbacks=entries=>{entries.forEach(fireObserverCallback)},thresholdNames={some:0,all:1},makeRenderlessComponent=
hook=>props=>{hook(props);return null},gestureAnimations={inView:makeRenderlessComponent(function($jscomp$destructuring$var22){var {visualElement,whileInView,onViewportEnter,onViewportLeave,viewport={}}=$jscomp$destructuring$var22;$jscomp$destructuring$var22=React.useRef({hasEnteredView:!1,isInView:!1});let shouldObserve=!!(whileInView||onViewportEnter||onViewportLeave);viewport.once&&$jscomp$destructuring$var22.current.hasEnteredView&&(shouldObserve=!1);("undefined"===typeof IntersectionObserver?
useMissingIntersectionObserver:useIntersectionObserver)(shouldObserve,$jscomp$destructuring$var22.current,visualElement,viewport)}),tap:makeRenderlessComponent(function($jscomp$destructuring$var18){function removePointerEndListener(){cancelPointerEndListeners.current&&cancelPointerEndListeners.current();cancelPointerEndListeners.current=null}function checkPointerEnd(){removePointerEndListener();isPressing.current=!1;visualElement.animationState&&visualElement.animationState.setActive(exports.AnimationType.Tap,
!1);return!isDragActive()}function onPointerUp(event,info){checkPointerEnd()&&(isNodeOrChild(visualElement.current,event.target)?onTap&&onTap(event,info):onTapCancel&&onTapCancel(event,info))}function onPointerCancel(event,info){checkPointerEnd()&&onTapCancel&&onTapCancel(event,info)}function onPointerDown(event,info){removePointerEndListener();isPressing.current||(isPressing.current=!0,cancelPointerEndListeners.current=[addPointerEvent(window,"pointerup",onPointerUp,eventOptions),addPointerEvent(window,
"pointercancel",onPointerCancel,eventOptions)].reduce(combineFunctions),visualElement.animationState&&visualElement.animationState.setActive(exports.AnimationType.Tap,!0),onTapStart&&onTapStart(event,info))}var {onTap,onTapStart,onTapCancel,whileTap,visualElement}=$jscomp$destructuring$var18;$jscomp$destructuring$var18=onTap||onTapStart||onTapCancel||whileTap;const isPressing=React.useRef(!1),cancelPointerEndListeners=React.useRef(null),eventOptions={passive:!(onTapStart||onTap||onTapCancel||onPointerDown)};
usePointerEvent(visualElement,"pointerdown",$jscomp$destructuring$var18?onPointerDown:void 0,eventOptions);useUnmountEffect(removePointerEndListener)}),focus:makeRenderlessComponent(function($jscomp$destructuring$var16){var {whileFocus,visualElement}=$jscomp$destructuring$var16;const {animationState}=visualElement;$jscomp$destructuring$var16=()=>{animationState&&animationState.setActive(exports.AnimationType.Focus,!1)};useDomEvent(visualElement,"focus",whileFocus?()=>{animationState&&animationState.setActive(exports.AnimationType.Focus,
!0)}:void 0);useDomEvent(visualElement,"blur",whileFocus?$jscomp$destructuring$var16:void 0)}),hover:makeRenderlessComponent(function($jscomp$destructuring$var17){var {onHoverStart,onHoverEnd,whileHover,visualElement}=$jscomp$destructuring$var17;usePointerEvent(visualElement,"pointerenter",onHoverStart||whileHover?createHoverEvent(visualElement,!0,onHoverStart):void 0,{passive:!onHoverStart});usePointerEvent(visualElement,"pointerleave",onHoverEnd||whileHover?createHoverEvent(visualElement,!1,onHoverEnd):
void 0,{passive:!onHoverEnd})})},noop=any=>any,mirrorEasing=easing=>p=>.5>=p?easing(2*p)/2:(2-easing(2*(1-p)))/2,reverseEasing=easing=>p=>1-easing(1-p),easeIn=p=>p*p,easeOut=reverseEasing(easeIn),easeInOut=mirrorEasing(easeIn),circIn=p=>1-Math.sin(Math.acos(p)),circOut=reverseEasing(circIn),circInOut=mirrorEasing(circOut),createBackIn=power=>{power=void 0===power?1.525:power;return p=>p*p*((power+1)*p-power)},backIn=createBackIn(),backOut=reverseEasing(backIn),backInOut=mirrorEasing(backIn),anticipate=
(power=>{const backEasing=createBackIn(power);return p=>1>(p*=2)?.5*backEasing(p):.5*(2-Math.pow(2,-10*(p-1)))})(),easingLookup={linear:noop,easeIn,easeInOut,easeOut,circIn,circInOut,circOut,backIn,backInOut,backOut,anticipate},easingDefinitionToFunction=definition=>{if(Array.isArray(definition)){heyListen.invariant(4===definition.length,"Cubic bezier arrays must contain four numerical values.");const [x1,y1,x2,y2]=definition;return cubicBezier(x1,y1,x2,y2)}return"string"===typeof definition?(heyListen.invariant(void 0!==
easingLookup[definition],`Invalid easing type '${definition}'`),easingLookup[definition]):definition},isAnimatable=(key,value)=>"zIndex"===key?!1:"number"===typeof value||Array.isArray(value)||"string"===typeof value&&styleValueTypes.complex.test(value)&&!value.startsWith("url(")?!0:!1,underDampedSpring=()=>({type:"spring",stiffness:500,damping:25,restSpeed:10}),criticallyDampedSpring=to=>({type:"spring",stiffness:550,damping:0===to?2*Math.sqrt(550):30,restSpeed:10}),linearTween=()=>({type:"keyframes",
ease:"linear",duration:.3}),keyframes$1=values=>({type:"keyframes",duration:.8,values}),defaultTransitions={x:underDampedSpring,y:underDampedSpring,z:underDampedSpring,rotate:underDampedSpring,rotateX:underDampedSpring,rotateY:underDampedSpring,rotateZ:underDampedSpring,scaleX:criticallyDampedSpring,scaleY:criticallyDampedSpring,scale:criticallyDampedSpring,opacity:linearTween,backgroundColor:linearTween,color:linearTween,default:criticallyDampedSpring},defaultValueTypes=Object.assign({},numberValueTypes,
{color:styleValueTypes.color,backgroundColor:styleValueTypes.color,outlineColor:styleValueTypes.color,fill:styleValueTypes.color,stroke:styleValueTypes.color,borderColor:styleValueTypes.color,borderTopColor:styleValueTypes.color,borderRightColor:styleValueTypes.color,borderBottomColor:styleValueTypes.color,borderLeftColor:styleValueTypes.color,filter:styleValueTypes.filter,WebkitFilter:styleValueTypes.filter}),instantAnimationState={current:!1},clamp=(min,max,v)=>Math.min(Math.max(v,min),max),mix=
(from,to,progress)=>-progress*from+progress*to+from,mixLinearColor=(from,to,v)=>{from*=from;return Math.sqrt(Math.max(0,v*(to*to-from)+from))},colorTypes=[styleValueTypes.hex,styleValueTypes.rgba,styleValueTypes.hsla],getColorType=v=>colorTypes.find(type=>type.test(v)),mixColor=(from,to)=>{const fromRGBA=asRGBA(from),toRGBA=asRGBA(to),blended=Object.assign({},fromRGBA);return v=>{blended.red=mixLinearColor(fromRGBA.red,toRGBA.red,v);blended.green=mixLinearColor(fromRGBA.green,toRGBA.green,v);blended.blue=
mixLinearColor(fromRGBA.blue,toRGBA.blue,v);blended.alpha=mix(fromRGBA.alpha,toRGBA.alpha,v);return styleValueTypes.rgba.transform(blended)}},mixArray=(from,to)=>{const output=[...from],numValues=output.length,blendValue=from.map((fromThis,i)=>getMixer$1(fromThis,to[i]));return v=>{for(let i=0;i<numValues;i++)output[i]=blendValue[i](v);return output}},mixObject=(origin,target)=>{const output=Object.assign({},origin,target),blendValue={};for(const key in output)void 0!==origin[key]&&void 0!==target[key]&&
(blendValue[key]=getMixer$1(origin[key],target[key]));return v=>{for(const key in blendValue)output[key]=blendValue[key](v);return output}},mixComplex=(origin,target)=>{const template=styleValueTypes.complex.createTransformer(target),originStats=analyse(origin),targetStats=analyse(target);if(originStats.numColors===targetStats.numColors&&originStats.numNumbers>=targetStats.numNumbers)return[mixArray(originStats.parsed,targetStats.parsed),template].reduce(combineFunctions);heyListen.warning(!0,`Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
return p=>`${0<p?target:origin}`},progress$jscomp$0=(from,to,value)=>{to-=from;return 0===to?1:(value-from)/to},mixNumber=(from,to)=>p=>-p*from+p*to+from,durationKeys=["duration","bounce"],physicsKeys=["stiffness","damping","mass"];spring.needsInterpolation=(a,b)=>"string"===typeof a||"string"===typeof b;const zero=_t=>0,types={decay:function($jscomp$destructuring$var33){var {velocity=0,from=0,power=.8,timeConstant=350,restDelta=.5,modifyTarget}=$jscomp$destructuring$var33;const state={done:!1,value:from};
let amplitude=power*velocity;$jscomp$destructuring$var33=from+amplitude;const target=void 0===modifyTarget?$jscomp$destructuring$var33:modifyTarget($jscomp$destructuring$var33);target!==$jscomp$destructuring$var33&&(amplitude=target-from);return{next:t=>{t=-amplitude*Math.exp(-t/timeConstant);state.done=!(t>restDelta||t<-restDelta);state.value=state.done?target:target+t;return state},flipTarget:()=>{}}},keyframes:function($jscomp$destructuring$var28){function createInterpolator(){return interpolate(times,
values,{ease:Array.isArray(ease)?ease:defaultEasing(values,ease)})}var {from=0,to=1,ease,offset,duration=300}=$jscomp$destructuring$var28;const state={done:!1,value:from},values=Array.isArray(to)?to:[from,to],times=convertOffsetToTimes(offset&&offset.length===values.length?offset:defaultOffset(values),duration);let interpolator=createInterpolator();return{next:t=>{state.value=interpolator(t);state.done=t>=duration;return state},flipTarget:()=>{values.reverse();interpolator=createInterpolator()}}},
spring},framesync=update=>{const passTimestamp=$jscomp$destructuring$var34=>{({delta:$jscomp$destructuring$var34}=$jscomp$destructuring$var34);return update($jscomp$destructuring$var34)};return{start:()=>sync__default["default"].update(passTimestamp,!0),stop:()=>sync.cancelSync.update(passTimestamp)}};let legacyRepeatWarning=!1;class SubscriptionManager{constructor(){this.subscriptions=[]}add(handler){addUniqueItem(this.subscriptions,handler);return()=>removeItem(this.subscriptions,handler)}notify(a,
b,c){const numSubscriptions=this.subscriptions.length;if(numSubscriptions)if(1===numSubscriptions)this.subscriptions[0](a,b,c);else for(let i=0;i<numSubscriptions;i++){const handler=this.subscriptions[i];handler&&handler(a,b,c)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}class MotionValue{constructor(init){this.version="7.6.19";this.lastUpdated=this.timeDelta=0;this.updateSubscribers=new SubscriptionManager;this.velocityUpdateSubscribers=new SubscriptionManager;
this.renderSubscribers=new SubscriptionManager;this.canTrackVelocity=!1;this.updateAndNotify=(v,render)=>{render=void 0===render?!0:render;this.prev=this.current;this.current=v;const {delta,timestamp}=sync.getFrameData();this.lastUpdated!==timestamp&&(this.timeDelta=delta,this.lastUpdated=timestamp,sync__default["default"].postRender(this.scheduleVelocityCheck));this.prev!==this.current&&this.updateSubscribers.notify(this.current);this.velocityUpdateSubscribers.getSize()&&this.velocityUpdateSubscribers.notify(this.getVelocity());
render&&this.renderSubscribers.notify(this.current)};this.scheduleVelocityCheck=()=>sync__default["default"].postRender(this.velocityCheck);this.velocityCheck=$jscomp$destructuring$var46=>{({timestamp:$jscomp$destructuring$var46}=$jscomp$destructuring$var46);$jscomp$destructuring$var46!==this.lastUpdated&&(this.prev=this.current,this.velocityUpdateSubscribers.notify(this.getVelocity()))};this.hasAnimated=!1;this.prev=this.current=init;this.canTrackVelocity=!isNaN(parseFloat(this.current))}onChange(subscription){return this.updateSubscribers.add(subscription)}clearListeners(){this.updateSubscribers.clear()}onRenderRequest(subscription){subscription(this.get());
return this.renderSubscribers.add(subscription)}attach(passiveEffect){this.passiveEffect=passiveEffect}set(v,render){(render=void 0===render?!0:render)&&this.passiveEffect?this.passiveEffect(v,this.updateAndNotify):this.updateAndNotify(v,render)}get(){return this.current}getPrevious(){return this.prev}getVelocity(){if(this.canTrackVelocity){var JSCompiler_temp=parseFloat(this.current)-parseFloat(this.prev);var frameDuration=this.timeDelta;JSCompiler_temp=frameDuration?1E3/frameDuration*JSCompiler_temp:
0}else JSCompiler_temp=0;return JSCompiler_temp}start(animation){this.stop();return(new Promise(resolve=>{this.hasAnimated=!0;this.stopAnimation=animation(resolve)})).then(()=>this.clearAnimation())}stop(){this.stopAnimation&&this.stopAnimation();this.clearAnimation()}isAnimating(){return!!this.stopAnimation}clearAnimation(){this.stopAnimation=null}destroy(){this.updateSubscribers.clear();this.renderSubscribers.clear();this.stop()}}const testValueType=v=>type=>type.test(v),dimensionValueTypes=[styleValueTypes.number,
styleValueTypes.px,styleValueTypes.percent,styleValueTypes.degrees,styleValueTypes.vw,styleValueTypes.vh,{test:v=>"auto"===v,parse:v=>v}],valueTypes=[...dimensionValueTypes,styleValueTypes.color,styleValueTypes.complex],variantPriorityOrder=[exports.AnimationType.Animate,exports.AnimationType.InView,exports.AnimationType.Focus,exports.AnimationType.Hover,exports.AnimationType.Tap,exports.AnimationType.Drag,exports.AnimationType.Exit],reversePriorityOrder=[...variantPriorityOrder].reverse(),numAnimationTypes=
variantPriorityOrder.length,animations$jscomp$0={animation:makeRenderlessComponent($jscomp$destructuring$var56=>{var {visualElement,animate}=$jscomp$destructuring$var56;visualElement.animationState||(visualElement.animationState=createAnimationState(visualElement));isAnimationControls(animate)&&React.useEffect(()=>animate.subscribe(visualElement),[animate])}),exit:makeRenderlessComponent(props=>{const {custom,visualElement}=props,[isPresent,safeToRemove]=usePresence(),presenceContext=React.useContext(PresenceContext);
React.useEffect(()=>{visualElement.isPresent=isPresent;const animation=visualElement.animationState&&visualElement.animationState.setActive(exports.AnimationType.Exit,!isPresent,{custom:presenceContext&&presenceContext.custom||custom});animation&&!isPresent&&animation.then(safeToRemove)},[isPresent])})};class PanSession{constructor(event$jscomp$0,handlers,$jscomp$destructuring$var57){({transformPagePoint:$jscomp$destructuring$var57}=void 0===$jscomp$destructuring$var57?{}:$jscomp$destructuring$var57);
this.lastMoveEventInfo=this.lastMoveEvent=this.startEvent=null;this.handlers={};this.updatePoint=()=>{if(this.lastMoveEvent&&this.lastMoveEventInfo){var info=getPanInfo(this.lastMoveEventInfo,this.history),isPanStarted=null!==this.startEvent,isDistancePastThreshold=3<=distance2D(info.offset,{x:0,y:0});if(isPanStarted||isDistancePastThreshold){({point:isDistancePastThreshold}=info);var {timestamp}=sync.getFrameData();this.history.push(Object.assign({},isDistancePastThreshold,{timestamp}));var {onStart,
onMove}=this.handlers;isPanStarted||(onStart&&onStart(this.lastMoveEvent,info),this.startEvent=this.lastMoveEvent);onMove&&onMove(this.lastMoveEvent,info)}}};this.handlePointerMove=(event,info)=>{this.lastMoveEvent=event;this.lastMoveEventInfo=transformPoint(info,this.transformPagePoint);isMouseEvent(event)&&0===event.buttons?this.handlePointerUp(event,info):sync__default["default"].update(this.updatePoint,!0)};this.handlePointerUp=(event,info)=>{this.end();const {onEnd,onSessionEnd}=this.handlers;
info=getPanInfo(transformPoint(info,this.transformPagePoint),this.history);this.startEvent&&onEnd&&onEnd(event,info);onSessionEnd&&onSessionEnd(event,info)};if(!(event$jscomp$0.touches&&1<event$jscomp$0.touches.length)){this.handlers=handlers;this.transformPagePoint=$jscomp$destructuring$var57;$jscomp$destructuring$var57=extractEventInfo(event$jscomp$0);$jscomp$destructuring$var57=transformPoint($jscomp$destructuring$var57,this.transformPagePoint);var {point}=$jscomp$destructuring$var57,{timestamp:timestamp$jscomp$0}=
sync.getFrameData();this.history=[Object.assign({},point,{timestamp:timestamp$jscomp$0})];({onSessionStart:handlers}=handlers);handlers&&handlers(event$jscomp$0,getPanInfo($jscomp$destructuring$var57,this.history));this.removeListeners=[addPointerEvent(window,"pointermove",this.handlePointerMove),addPointerEvent(window,"pointerup",this.handlePointerUp),addPointerEvent(window,"pointercancel",this.handlePointerUp)].reduce(combineFunctions)}}updateHandlers(handlers){this.handlers=handlers}end(){this.removeListeners&&
this.removeListeners();sync.cancelSync.update(this.updatePoint)}}const createAxisDelta=()=>({translate:0,scale:1,origin:0,originPoint:0}),createBox=()=>({x:{min:0,max:0},y:{min:0,max:0}}),xKeys$1=["x","scaleX","originX"],yKeys$1=["y","scaleY","originY"],elementDragControls=new WeakMap;class VisualElementDragControls{constructor(visualElement){this.openGlobalLock=null;this.isDragging=!1;this.currentDirection=null;this.originPoint={x:0,y:0};this.hasMutatedConstraints=this.constraints=!1;this.elastic=
createBox();this.visualElement=visualElement}start(originEvent,$jscomp$destructuring$var66){var {snapToCursor=!1}=void 0===$jscomp$destructuring$var66?{}:$jscomp$destructuring$var66;!1!==this.visualElement.isPresent&&(this.panSession=new PanSession(originEvent,{onSessionStart:event=>{this.stopAnimation();snapToCursor&&this.snapToCursor(extractEventInfo(event,"page").point)},onStart:(event,info)=>{var _a$jscomp$0;const {drag,dragPropagation,onDragStart}=this.getProps();if(drag&&!dragPropagation&&(this.openGlobalLock&&
this.openGlobalLock(),this.openGlobalLock=getGlobalLock(drag),!this.openGlobalLock))return;this.isDragging=!0;this.currentDirection=null;this.resolveConstraints();this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0);eachAxis(axis=>{var _a,_b;let current=this.getAxisMotionValue(axis).get()||0;if(styleValueTypes.percent.test(current)){const measuredAxis=null===(_b=null===(_a=this.visualElement.projection)||void 0===_a?void 0:
_a.layout)||void 0===_b?void 0:_b.layoutBox[axis];measuredAxis&&(current=calcLength(measuredAxis)*(parseFloat(current)/100))}this.originPoint[axis]=current});null===onDragStart||void 0===onDragStart?void 0:onDragStart(event,info);null===(_a$jscomp$0=this.visualElement.animationState)||void 0===_a$jscomp$0?void 0:_a$jscomp$0.setActive(exports.AnimationType.Drag,!0)},onMove:(event,info)=>{const {dragPropagation,dragDirectionLock,onDirectionLock,onDrag}=this.getProps();if(dragPropagation||this.openGlobalLock){var {offset}=
info;dragDirectionLock&&null===this.currentDirection?(event=void 0,event=void 0===event?10:event,info=null,Math.abs(offset.y)>event?info="y":Math.abs(offset.x)>event&&(info="x"),this.currentDirection=info,null!==this.currentDirection&&(null===onDirectionLock||void 0===onDirectionLock?void 0:onDirectionLock(this.currentDirection))):(this.updateAxis("x",info.point,offset),this.updateAxis("y",info.point,offset),this.visualElement.render(),null===onDrag||void 0===onDrag?void 0:onDrag(event,info))}},onSessionEnd:(event,
info)=>this.stop(event,info)},{transformPagePoint:this.visualElement.getTransformPagePoint()}))}stop(event,info){var isDragging=this.isDragging;this.cancel();isDragging&&({velocity:isDragging}=info,this.startAnimation(isDragging),{onDragEnd:isDragging}=this.getProps(),null===isDragging||void 0===isDragging?void 0:isDragging(event,info))}cancel(){var _a,_b;this.isDragging=!1;this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!1);null===(_a=this.panSession)||void 0===_a?
void 0:_a.end();this.panSession=void 0;({dragPropagation:_a}=this.getProps());!_a&&this.openGlobalLock&&(this.openGlobalLock(),this.openGlobalLock=null);null===(_b=this.visualElement.animationState)||void 0===_b?void 0:_b.setActive(exports.AnimationType.Drag,!1)}updateAxis(axis,_point,offset){({drag:_point}=this.getProps());if(offset&&shouldDrag(axis,_point,this.currentDirection)){_point=this.getAxisMotionValue(axis);offset=this.originPoint[axis]+offset[axis];if(this.constraints&&this.constraints[axis]){var elastic=
this.elastic[axis],{min,max}=this.constraints[axis];void 0!==min&&offset<min?offset=elastic?mix(min,offset,elastic.min):Math.max(offset,min):void 0!==max&&offset>max&&(offset=elastic?mix(max,offset,elastic.max):Math.min(offset,max))}_point.set(offset)}}resolveConstraints(){const {dragConstraints,dragElastic}=this.getProps(),{layout:layout$jscomp$0}=this.visualElement.projection||{},prevConstraints=this.constraints;dragConstraints&&isRefObject(dragConstraints)?this.constraints||(this.constraints=this.resolveRefConstraints()):
this.constraints=dragConstraints&&layout$jscomp$0?calcRelativeConstraints(layout$jscomp$0.layoutBox,dragConstraints):!1;this.elastic=resolveDragElastic(dragElastic);prevConstraints!==this.constraints&&layout$jscomp$0&&this.constraints&&!this.hasMutatedConstraints&&eachAxis(axis=>{if(this.getAxisMotionValue(axis)){var JSCompiler_temp_const=this.constraints,layout=layout$jscomp$0.layoutBox[axis],constraints=this.constraints[axis];const relativeConstraints={};void 0!==constraints.min&&(relativeConstraints.min=
constraints.min-layout.min);void 0!==constraints.max&&(relativeConstraints.max=constraints.max-layout.min);JSCompiler_temp_const[axis]=relativeConstraints}})}resolveRefConstraints(){const {dragConstraints:constraints,onMeasureDragConstraints}=this.getProps();if(!constraints||!isRefObject(constraints))return!1;var constraintsElement=constraints.current;heyListen.invariant(null!==constraintsElement,"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
var {projection}=this.visualElement;if(!projection||!projection.layout)return!1;var rootProjectionNode=projection.root,transformPoint=this.visualElement.getTransformPagePoint();constraintsElement=convertBoundingBoxToBox(transformBoxPoints(constraintsElement.getBoundingClientRect(),transformPoint));({scroll:rootProjectionNode}=rootProjectionNode);rootProjectionNode&&(translateAxis(constraintsElement.x,rootProjectionNode.offset.x),translateAxis(constraintsElement.y,rootProjectionNode.offset.y));projection=
projection.layout.layoutBox;projection={x:calcViewportAxisConstraints(projection.x,constraintsElement.x),y:calcViewportAxisConstraints(projection.y,constraintsElement.y)};if(onMeasureDragConstraints){var {x,y}=projection;rootProjectionNode=onMeasureDragConstraints({top:y.min,right:x.max,bottom:y.max,left:x.min});this.hasMutatedConstraints=!!rootProjectionNode;rootProjectionNode&&(projection=convertBoundingBoxToBox(rootProjectionNode))}return projection}startAnimation(velocity){const {drag,dragMomentum,
dragElastic,dragTransition,dragSnapToOrigin,onDragTransitionEnd}=this.getProps(),constraints=this.constraints||{},momentumAnimations=eachAxis(axis=>{var _a;if(shouldDrag(axis,drag,this.currentDirection)){var transition=null!==(_a=null===constraints||void 0===constraints?void 0:constraints[axis])&&void 0!==_a?_a:{};dragSnapToOrigin&&(transition={min:0,max:0});_a=Object.assign({},{type:"inertia",velocity:dragMomentum?velocity[axis]:0,bounceStiffness:dragElastic?200:1E6,bounceDamping:dragElastic?40:
1E7,timeConstant:750,restDelta:1,restSpeed:10},dragTransition,transition);return this.startAxisValueAnimation(axis,_a)}});return Promise.all(momentumAnimations).then(onDragTransitionEnd)}startAxisValueAnimation(axis,transition){const axisValue=this.getAxisMotionValue(axis);return startAnimation(axis,axisValue,0,transition)}stopAnimation(){eachAxis(axis=>this.getAxisMotionValue(axis).stop())}getAxisMotionValue(axis){var _a,_b,dragKey="_drag"+axis.toUpperCase();return(dragKey=this.visualElement.getProps()[dragKey])?
dragKey:this.visualElement.getValue(axis,null!==(_b=null===(_a=this.visualElement.getProps().initial)||void 0===_a?void 0:_a[axis])&&void 0!==_b?_b:0)}snapToCursor(point){eachAxis(axis=>{var {drag}=this.getProps();if(shouldDrag(axis,drag,this.currentDirection)){({projection:drag}=this.visualElement);var axisValue=this.getAxisMotionValue(axis);if(drag&&drag.layout){const {min,max}=drag.layout.layoutBox[axis];axisValue.set(point[axis]-(-.5*min+.5*max+min))}}})}scalePositionWithinConstraints(){var _a;
if(this.visualElement.current){var {drag,dragConstraints}=this.getProps(),{projection}=this.visualElement;if(isRefObject(dragConstraints)&&projection&&this.constraints){this.stopAnimation();var boxProgress={x:0,y:0};eachAxis(axis=>{var axisValue=this.getAxisMotionValue(axis);if(axisValue){axisValue=axisValue.get();axisValue={min:axisValue,max:axisValue};var target=this.constraints[axis];let origin=.5;const sourceLength=calcLength(axisValue),targetLength=calcLength(target);targetLength>sourceLength?
origin=progress$jscomp$0(target.min,target.max-sourceLength,axisValue.min):sourceLength>targetLength&&(origin=progress$jscomp$0(axisValue.min,axisValue.max-targetLength,target.min));axisValue=clamp(0,1,origin);boxProgress[axis]=axisValue}});var {transformTemplate}=this.visualElement.getProps();this.visualElement.current.style.transform=transformTemplate?transformTemplate({},""):"none";null===(_a=projection.root)||void 0===_a?void 0:_a.updateScroll();projection.updateLayout();this.resolveConstraints();
eachAxis(axis=>{if(shouldDrag(axis,drag,null)){var axisValue=this.getAxisMotionValue(axis),{min,max}=this.constraints[axis];axisValue.set(mix(min,max,boxProgress[axis]))}})}}}addListeners(){var _a;if(this.visualElement.current){elementDragControls.set(this.visualElement,this);var stopPointerListener=addPointerEvent(this.visualElement.current,"pointerdown",event=>{const {drag,dragListener=!0}=this.getProps();drag&&dragListener&&this.start(event)}),measureDragConstraints=()=>{const {dragConstraints}=
this.getProps();isRefObject(dragConstraints)&&(this.constraints=this.resolveRefConstraints())},{projection}=this.visualElement,stopMeasureLayoutListener=projection.addEventListener("measure",measureDragConstraints);projection&&!projection.layout&&(null===(_a=projection.root)||void 0===_a?void 0:_a.updateScroll(),projection.updateLayout());measureDragConstraints();var stopResizeListener=addDomEvent(window,"resize",()=>this.scalePositionWithinConstraints()),stopLayoutUpdateListener=projection.addEventListener("didUpdate",
$jscomp$destructuring$var67=>{var {delta,hasLayoutChanged}=$jscomp$destructuring$var67;this.isDragging&&hasLayoutChanged&&(eachAxis(axis=>{const motionValue=this.getAxisMotionValue(axis);motionValue&&(this.originPoint[axis]+=delta[axis].translate,motionValue.set(motionValue.get()+delta[axis].translate))}),this.visualElement.render())});return()=>{stopResizeListener();stopPointerListener();stopMeasureLayoutListener();null===stopLayoutUpdateListener||void 0===stopLayoutUpdateListener?void 0:stopLayoutUpdateListener()}}}getProps(){const props=
this.visualElement.getProps(),{drag=!1,dragDirectionLock=!1,dragPropagation=!1,dragConstraints=!1,dragElastic=.35,dragMomentum=!0}=props;return Object.assign({},props,{drag,dragDirectionLock,dragPropagation,dragConstraints,dragElastic,dragMomentum})}}const drag={pan:makeRenderlessComponent(function($jscomp$destructuring$var68){function onPointerDown(event){panSession.current=new PanSession(event,handlers,{transformPagePoint})}var {onPan,onPanStart,onPanEnd,onPanSessionStart,visualElement}=$jscomp$destructuring$var68;
$jscomp$destructuring$var68=onPan||onPanStart||onPanEnd||onPanSessionStart;const panSession=React.useRef(null),{transformPagePoint}=React.useContext(MotionConfigContext),handlers={onSessionStart:onPanSessionStart,onStart:onPanStart,onMove:onPan,onEnd:(event,info)=>{panSession.current=null;onPanEnd&&onPanEnd(event,info)}};React.useEffect(()=>{null!==panSession.current&&panSession.current.updateHandlers(handlers)});usePointerEvent(visualElement,"pointerdown",$jscomp$destructuring$var68&&onPointerDown);
useUnmountEffect(()=>panSession.current&&panSession.current.end())}),drag:makeRenderlessComponent(function(props){const {dragControls:groupDragControls,visualElement}=props,dragControls=useConstant(()=>new VisualElementDragControls(visualElement));React.useEffect(()=>groupDragControls&&groupDragControls.subscribe(dragControls),[dragControls,groupDragControls]);React.useEffect(()=>dragControls.addListeners(),[dragControls])})},cssVariableRegex=/var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/,
positionalKeys=new Set("width height top left right bottom x y".split(" ")),isPositionalKey=key=>positionalKeys.has(key);var BoundingBoxDimension;(function(BoundingBoxDimension){BoundingBoxDimension.width="width";BoundingBoxDimension.height="height";BoundingBoxDimension.left="left";BoundingBoxDimension.right="right";BoundingBoxDimension.top="top";BoundingBoxDimension.bottom="bottom"})(BoundingBoxDimension||(BoundingBoxDimension={}));const getTranslateFromMatrix=(pos2,pos3)=>(_bbox,$jscomp$destructuring$var72)=>
{({transform:_bbox}=$jscomp$destructuring$var72);return"none"!==_bbox&&_bbox?($jscomp$destructuring$var72=_bbox.match(/^matrix3d\((.+)\)$/))?parseFloat($jscomp$destructuring$var72[1].split(", ")[pos3]):(_bbox=_bbox.match(/^matrix\((.+)\)$/))?parseFloat(_bbox[1].split(", ")[pos2]):0:0},transformKeys$jscomp$0=new Set(["x","y","z"]),nonTranslationalTransformKeys=transformPropOrder.filter(key=>!transformKeys$jscomp$0.has(key)),positionalValues={width:($jscomp$destructuring$var73,$jscomp$destructuring$var74)=>
{({x:$jscomp$destructuring$var73}=$jscomp$destructuring$var73);var {paddingLeft="0",paddingRight="0"}=$jscomp$destructuring$var74;return $jscomp$destructuring$var73.max-$jscomp$destructuring$var73.min-parseFloat(paddingLeft)-parseFloat(paddingRight)},height:($jscomp$destructuring$var75,$jscomp$destructuring$var76)=>{({y:$jscomp$destructuring$var75}=$jscomp$destructuring$var75);var {paddingTop="0",paddingBottom="0"}=$jscomp$destructuring$var76;return $jscomp$destructuring$var75.max-$jscomp$destructuring$var75.min-
parseFloat(paddingTop)-parseFloat(paddingBottom)},top:(_bbox,$jscomp$destructuring$var77)=>{({top:_bbox}=$jscomp$destructuring$var77);return parseFloat(_bbox)},left:(_bbox,$jscomp$destructuring$var78)=>{({left:_bbox}=$jscomp$destructuring$var78);return parseFloat(_bbox)},bottom:($jscomp$destructuring$var79,$jscomp$destructuring$var80)=>{({y:$jscomp$destructuring$var79}=$jscomp$destructuring$var79);({top:$jscomp$destructuring$var80}=$jscomp$destructuring$var80);return parseFloat($jscomp$destructuring$var80)+
($jscomp$destructuring$var79.max-$jscomp$destructuring$var79.min)},right:($jscomp$destructuring$var81,$jscomp$destructuring$var82)=>{({x:$jscomp$destructuring$var81}=$jscomp$destructuring$var81);({left:$jscomp$destructuring$var82}=$jscomp$destructuring$var82);return parseFloat($jscomp$destructuring$var82)+($jscomp$destructuring$var81.max-$jscomp$destructuring$var81.min)},x:getTranslateFromMatrix(4,13),y:getTranslateFromMatrix(5,14)},convertChangedValueTypes=(target,visualElement,changedKeys)=>{const originBbox=
visualElement.measureViewportBox(),elementComputedStyle=getComputedStyle(visualElement.current),{display}=elementComputedStyle,origin={};"none"===display&&visualElement.setStaticValue("display",target.display||"block");changedKeys.forEach(key=>{origin[key]=positionalValues[key](originBbox,elementComputedStyle)});visualElement.render();const targetBbox=visualElement.measureViewportBox();changedKeys.forEach(key=>{var value=visualElement.getValue(key),to=origin[key];value.set(to,!1);value.set(to);target[key]=
positionalValues[key](targetBbox,elementComputedStyle)});return target},checkAndConvertChangedValueTypes=(visualElement,target,origin,transitionEnd)=>{origin=void 0===origin?{}:origin;transitionEnd=void 0===transitionEnd?{}:transitionEnd;target=Object.assign({},target);transitionEnd=Object.assign({},transitionEnd);let removedTransformValues=[],hasAttemptedToRemoveTransformValues=!1;const changedValueTypeKeys=[];Object.keys(target).filter(isPositionalKey).forEach(key=>{const value=visualElement.getValue(key);
if(visualElement.hasValue(key)){var from=origin[key],fromType=dimensionValueTypes.find(testValueType(from)),to=target[key];if(Array.isArray(to)){const numKeyframes=to.length;var fromIndex=null===to[0]?1:0;from=to[fromIndex];for(fromType=dimensionValueTypes.find(testValueType(from));fromIndex<numKeyframes;fromIndex++)if(toType)heyListen.invariant(dimensionValueTypes.find(testValueType(to[fromIndex]))===toType,"All keyframes must be of the same type");else{var toType=dimensionValueTypes.find(testValueType(to[fromIndex]));
heyListen.invariant(toType===fromType||(fromType===styleValueTypes.number||fromType===styleValueTypes.px)&&(toType===styleValueTypes.number||toType===styleValueTypes.px),"Keyframes must be of the same dimension as the current value")}}else toType=dimensionValueTypes.find(testValueType(to));fromType!==toType&&(fromType!==styleValueTypes.number&&fromType!==styleValueTypes.px||toType!==styleValueTypes.number&&toType!==styleValueTypes.px?(null===fromType||void 0===fromType?0:fromType.transform)&&(null===
toType||void 0===toType?0:toType.transform)&&(0===from||0===to)?0===from?value.set(toType.transform(from)):target[key]=fromType.transform(to):(hasAttemptedToRemoveTransformValues||(removedTransformValues=removeNonTranslationalTransform(visualElement),hasAttemptedToRemoveTransformValues=!0),changedValueTypeKeys.push(key),transitionEnd[key]=void 0!==transitionEnd[key]?transitionEnd[key]:target[key],value.set(to,!1),value.set(to)):(from=value.get(),"string"===typeof from&&value.set(parseFloat(from)),
"string"===typeof to?target[key]=parseFloat(to):Array.isArray(to)&&toType===styleValueTypes.px&&(target[key]=to.map(parseFloat))))}});if(changedValueTypeKeys.length){const scrollY=0<=changedValueTypeKeys.indexOf("height")?window.pageYOffset:null,convertedTarget=convertChangedValueTypes(target,visualElement,changedValueTypeKeys);removedTransformValues.length&&removedTransformValues.forEach($jscomp$destructuring$var83=>{var [key,value]=$jscomp$destructuring$var83;visualElement.getValue(key).set(value)});
visualElement.render();isBrowser&&null!==scrollY&&window.scrollTo({top:scrollY});return{target:convertedTarget,transitionEnd}}return{target,transitionEnd}};var JSCompiler_object_inline_current_5835=null;var JSCompiler_object_inline_current_5836=!1;const featureNames=Object.keys(featureDefinitions),numFeatures=featureNames.length,propEventHandlers="AnimationStart AnimationComplete Update Unmount BeforeLayoutMeasure LayoutMeasure LayoutAnimationStart LayoutAnimationComplete".split(" ");class VisualElement{constructor($jscomp$destructuring$var84,
options){var {parent,props,reducedMotionConfig,visualState}=$jscomp$destructuring$var84;options=void 0===options?{}:options;this.current=null;this.children=new Set;this.isControllingVariants=this.isVariantNode=!1;this.shouldReduceMotion=null;this.values=new Map;this.isPresent=!0;this.valueSubscriptions=new Map;this.prevMotionValues={};this.events={};this.propEventSubscriptions={};this.notifyUpdate=()=>this.notify("Update",this.latestValues);this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,
this.renderState,this.props.style,this.projection))};this.scheduleRender=()=>sync__default["default"].render(this.render,!1,!0);const {latestValues,renderState}=visualState;this.latestValues=latestValues;this.baseTarget=Object.assign({},latestValues);this.initialValues=props.initial?Object.assign({},latestValues):{};this.renderState=renderState;this.parent=parent;this.props=props;this.depth=parent?parent.depth+1:0;this.reducedMotionConfig=reducedMotionConfig;this.options=options;this.isControllingVariants=
isControllingVariants(props);if(this.isVariantNode=isVariantNode(props))this.variantChildren=new Set;this.manuallyAnimateOnMount=!(!parent||!parent.current);$jscomp$destructuring$var84=this.scrapeMotionValuesFromProps(props);options=Object.assign({},$jscomp$destructuring$var84);$jscomp$destructuring$var84=$jscomp$destructuring$var84.willChange;options=(delete options.willChange,options);for(const key in options){const value=options[key];void 0!==latestValues[key]&&isMotionValue(value)&&(value.set(latestValues[key],
!1),isWillChangeMotionValue($jscomp$destructuring$var84)&&$jscomp$destructuring$var84.add(key))}}scrapeMotionValuesFromProps(_props){return{}}mount(instance){var _a;this.current=instance;this.projection&&this.projection.mount(instance);this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=null===(_a=this.parent)||void 0===_a?void 0:_a.addVariantChild(this));this.values.forEach((value,key)=>this.bindToMotionValue(key,value));JSCompiler_object_inline_current_5836||
initPrefersReducedMotion();this.shouldReduceMotion="never"===this.reducedMotionConfig?!1:"always"===this.reducedMotionConfig?!0:JSCompiler_object_inline_current_5835;this.parent&&this.parent.children.add(this);this.setProps(this.props)}unmount(){var _a,_b,_c;null===(_a=this.projection)||void 0===_a?void 0:_a.unmount();sync.cancelSync.update(this.notifyUpdate);sync.cancelSync.render(this.render);this.valueSubscriptions.forEach(remove=>remove());null===(_b=this.removeFromVariantTree)||void 0===_b?void 0:
_b.call(this);null===(_c=this.parent)||void 0===_c?void 0:_c.children.delete(this);for(const key in this.events)this.events[key].clear();this.current=null}bindToMotionValue(key,value){const valueIsTransform=transformProps.has(key),removeOnChange=value.onChange(latestValue=>{this.latestValues[key]=latestValue;this.props.onUpdate&&sync__default["default"].update(this.notifyUpdate,!1,!0);valueIsTransform&&this.projection&&(this.projection.isTransformDirty=!0)}),removeOnRenderRequest=value.onRenderRequest(this.scheduleRender);
this.valueSubscriptions.set(key,()=>{removeOnChange();removeOnRenderRequest()})}sortNodePosition(other){return this.current&&this.sortInstanceNodePosition&&this.type===other.type?this.sortInstanceNodePosition(this.current,other.current):0}loadFeatures(renderedProps,isStrict,preloadedFeatures,projectionId,ProjectionNodeConstructor,initialLayoutGroupConfig){const features=[];"production"!==env&&preloadedFeatures&&isStrict&&heyListen.invariant(!1,"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.");
for(isStrict=0;isStrict<numFeatures;isStrict++){preloadedFeatures=featureNames[isStrict];const {isEnabled,Component}=featureDefinitions[preloadedFeatures];isEnabled(renderedProps)&&Component&&features.push(React.createElement(Component,Object.assign({},{key:preloadedFeatures},renderedProps,{visualElement:this})))}if(!this.projection&&ProjectionNodeConstructor){this.projection=new ProjectionNodeConstructor(projectionId,this.latestValues,this.parent&&this.parent.projection);const {layoutId,layout,drag,
dragConstraints,layoutScroll}=renderedProps;this.projection.setOptions({layoutId,layout,alwaysMeasureLayout:!!drag||dragConstraints&&isRefObject(dragConstraints),visualElement:this,scheduleRender:()=>this.scheduleRender(),animationType:"string"===typeof layout?layout:"both",initialPromotionConfig:initialLayoutGroupConfig,layoutScroll})}return features}triggerBuild(){this.build(this.renderState,this.latestValues,this.options,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,
this.props):createBox()}getStaticValue(key){return this.latestValues[key]}setStaticValue(key,value){this.latestValues[key]=value}makeTargetAnimatable(target,canMutate){return this.makeTargetAnimatableFromInstance(target,this.props,void 0===canMutate?!0:canMutate)}setProps(props){(props.transformTemplate||this.props.transformTemplate)&&this.scheduleRender();this.props=props;for(var i=0;i<propEventHandlers.length;i++){var key$jscomp$0=propEventHandlers[i];this.propEventSubscriptions[key$jscomp$0]&&
(this.propEventSubscriptions[key$jscomp$0](),delete this.propEventSubscriptions[key$jscomp$0]);var listener=props["on"+key$jscomp$0];listener&&(this.propEventSubscriptions[key$jscomp$0]=this.on(key$jscomp$0,listener))}props=this.scrapeMotionValuesFromProps(props);i=this.prevMotionValues;({willChange:key$jscomp$0}=props);for(const key in props){listener=props[key];var prevValue=i[key];isMotionValue(listener)?(this.addValue(key,listener),isWillChangeMotionValue(key$jscomp$0)&&key$jscomp$0.add(key),
warnOnce("7.6.19"===listener.version,`Attempting to mix Framer Motion versions ${listener.version} with 7.6.19 may not work as expected.`)):isMotionValue(prevValue)?(this.addValue(key,motionValue$jscomp$0(listener)),isWillChangeMotionValue(key$jscomp$0)&&key$jscomp$0.remove(key)):prevValue!==listener&&(this.hasValue(key)?(prevValue=this.getValue(key),!prevValue.hasAnimated&&prevValue.set(listener)):(prevValue=this.getStaticValue(key),this.addValue(key,motionValue$jscomp$0(void 0!==prevValue?prevValue:
listener))))}for(const key in i)void 0===props[key]&&this.removeValue(key);this.prevMotionValues=props}getProps(){return this.props}getVariant(name){var _a;return null===(_a=this.props.variants)||void 0===_a?void 0:_a[name]}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){var _a;return this.isVariantNode?this:null===(_a=this.parent)||void 0===_a?void 0:_a.getClosestVariantNode()}getVariantContext(startAtParent){var _a,
_b;if(void 0===startAtParent?0:startAtParent)return null===(_a=this.parent)||void 0===_a?void 0:_a.getVariantContext();if(!this.isControllingVariants)return startAtParent=(null===(_b=this.parent)||void 0===_b?void 0:_b.getVariantContext())||{},void 0!==this.props.initial&&(startAtParent.initial=this.props.initial),startAtParent;_b={};for(startAtParent=0;startAtParent<numVariantProps;startAtParent++){_a=variantProps[startAtParent];const prop=this.props[_a];if(isVariantLabel(prop)||!1===prop)_b[_a]=
prop}return _b}addVariantChild(child){var _a;const closestVariantNode=this.getClosestVariantNode();if(closestVariantNode)return null===(_a=closestVariantNode.variantChildren)||void 0===_a?void 0:_a.add(child),()=>closestVariantNode.variantChildren.delete(child)}addValue(key,value){this.hasValue(key)&&this.removeValue(key);this.values.set(key,value);this.latestValues[key]=value.get();this.bindToMotionValue(key,value)}removeValue(key){var _a;this.values.delete(key);null===(_a=this.valueSubscriptions.get(key))||
void 0===_a?void 0:_a();this.valueSubscriptions.delete(key);delete this.latestValues[key];this.removeValueFromRenderState(key,this.renderState)}hasValue(key){return this.values.has(key)}getValue(key,defaultValue){if(this.props.values&&this.props.values[key])return this.props.values[key];let value=this.values.get(key);void 0===value&&void 0!==defaultValue&&(value=motionValue$jscomp$0(defaultValue),this.addValue(key,value));return value}readValue(key){return void 0===this.latestValues[key]&&this.current?
this.readValueFromInstance(this.current,key,this.options):this.latestValues[key]}setBaseTarget(key,value){this.baseTarget[key]=value}getBaseTarget(key){var _a;const {initial}=this.props,valueFromInitial="string"===typeof initial||"object"===typeof initial?null===(_a=resolveVariantFromProps(this.props,initial))||void 0===_a?void 0:_a[key]:void 0;if(initial&&void 0!==valueFromInitial)return valueFromInitial;_a=this.getBaseTargetFromProps(this.props,key);return void 0===_a||isMotionValue(_a)?void 0!==
this.initialValues[key]&&void 0===valueFromInitial?void 0:this.baseTarget[key]:_a}on(eventName,callback){this.events[eventName]||(this.events[eventName]=new SubscriptionManager);return this.events[eventName].add(callback)}notify(eventName,...args){var _a;null===(_a=this.events[eventName])||void 0===_a?void 0:_a.notify(...args)}}const variantProps=["initial",...variantPriorityOrder],numVariantProps=variantProps.length;class DOMVisualElement extends VisualElement{sortInstanceNodePosition(a,b){return a.compareDocumentPosition(b)&
2?1:-1}getBaseTargetFromProps(props,key){var _a;return null===(_a=props.style)||void 0===_a?void 0:_a[key]}removeValueFromRenderState(key,$jscomp$destructuring$var87){var {vars,style}=$jscomp$destructuring$var87;delete vars[key];delete style[key]}makeTargetAnimatableFromInstance($jscomp$destructuring$var88,$jscomp$destructuring$var89,isMounted){var $jscomp$destructuring$var91=Object.assign({},$jscomp$destructuring$var88),transition=$jscomp$destructuring$var88.transition;$jscomp$destructuring$var88=
$jscomp$destructuring$var88.transitionEnd;$jscomp$destructuring$var91=(delete $jscomp$destructuring$var91.transition,delete $jscomp$destructuring$var91.transitionEnd,$jscomp$destructuring$var91);({transformValues:$jscomp$destructuring$var89}=$jscomp$destructuring$var89);let origin=getOrigin($jscomp$destructuring$var91,transition||{},this);$jscomp$destructuring$var89&&($jscomp$destructuring$var88&&($jscomp$destructuring$var88=$jscomp$destructuring$var89($jscomp$destructuring$var88)),$jscomp$destructuring$var91&&
($jscomp$destructuring$var91=$jscomp$destructuring$var89($jscomp$destructuring$var91)),origin&&(origin=$jscomp$destructuring$var89(origin)));isMounted&&(checkTargetForNewValues(this,$jscomp$destructuring$var91,origin),isMounted=origin,$jscomp$destructuring$var91=resolveCSSVariables(this,$jscomp$destructuring$var91,$jscomp$destructuring$var88),$jscomp$destructuring$var88=$jscomp$destructuring$var91.target,$jscomp$destructuring$var91=$jscomp$destructuring$var91.transitionEnd,isMounted=Object.keys($jscomp$destructuring$var88).some(isPositionalKey)?
checkAndConvertChangedValueTypes(this,$jscomp$destructuring$var88,isMounted,$jscomp$destructuring$var91):{target:$jscomp$destructuring$var88,transitionEnd:$jscomp$destructuring$var91},$jscomp$destructuring$var88=isMounted.transitionEnd,$jscomp$destructuring$var91=isMounted.target);return Object.assign({},{transition,transitionEnd:$jscomp$destructuring$var88},$jscomp$destructuring$var91)}}class HTMLVisualElement extends DOMVisualElement{readValueFromInstance(instance,key){if(transformProps.has(key))return(key=
defaultValueTypes[key])?key.default||0:0;instance=window.getComputedStyle(instance);key=(key.startsWith("--")?instance.getPropertyValue(key):instance[key])||0;return"string"===typeof key?key.trim():key}measureInstanceViewportBox(instance,$jscomp$destructuring$var92){({transformPagePoint:$jscomp$destructuring$var92}=$jscomp$destructuring$var92);return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(),$jscomp$destructuring$var92))}build(renderState,latestValues,options,props){buildHTMLStyles(renderState,
latestValues,options,props.transformTemplate)}scrapeMotionValuesFromProps(props){return scrapeMotionValuesFromProps$1(props)}renderInstance(instance,renderState,styleProp,projection){renderHTML(instance,renderState,styleProp,projection)}}class SVGVisualElement extends DOMVisualElement{constructor(){super(...arguments);this.isSVGTag=!1}getBaseTargetFromProps(props,key){return props[key]}readValueFromInstance(instance,key){var _a;if(transformProps.has(key))return(null===(_a=defaultValueTypes[key])||
void 0===_a?void 0:_a.default)||0;key=camelCaseAttributes.has(key)?key:camelToDash(key);return instance.getAttribute(key)}measureInstanceViewportBox(){return createBox()}scrapeMotionValuesFromProps(props){return scrapeMotionValuesFromProps(props)}build(renderState,latestValues,options,props){buildSVGAttrs(renderState,latestValues,options,this.isSVGTag,props.transformTemplate)}renderInstance(instance,renderState,styleProp,projection){renderSVG(instance,renderState,styleProp,projection)}mount(instance){this.isSVGTag=
isSVGTag(instance.tagName);super.mount(instance)}}const createDomVisualElement=(Component,options)=>isSVGComponent(Component)?new SVGVisualElement(options,{enableHardwareAcceleration:!1}):new HTMLVisualElement(options,{enableHardwareAcceleration:!0}),correctBorderRadius={correct:(latest,node)=>{if(!node.target)return latest;if("string"===typeof latest)if(styleValueTypes.px.test(latest))latest=parseFloat(latest);else return latest;const x=pixelsToPercent(latest,node.target.x);latest=pixelsToPercent(latest,
node.target.y);return`${x}% ${latest}%`}};class MeasureLayoutWithContext extends React__default["default"].Component{componentDidMount(){const {visualElement,layoutGroup,switchLayoutGroup,layoutId}=this.props,{projection}=visualElement;addScaleCorrector(defaultScaleCorrectors);projection&&(layoutGroup.group&&layoutGroup.group.add(projection),switchLayoutGroup&&switchLayoutGroup.register&&layoutId&&switchLayoutGroup.register(projection),projection.root.didUpdate(),projection.addEventListener("animationComplete",
()=>{this.safeToRemove()}),projection.setOptions(Object.assign({},projection.options,{onExitComplete:()=>this.safeToRemove()})));globalProjectionState.hasEverUpdated=!0}getSnapshotBeforeUpdate(prevProps){const {layoutDependency,visualElement,drag,isPresent}=this.props,projection=visualElement.projection;if(!projection)return null;projection.isPresent=isPresent;drag||prevProps.layoutDependency!==layoutDependency||void 0===layoutDependency?projection.willUpdate():this.safeToRemove();prevProps.isPresent!==
isPresent&&(isPresent?projection.promote():projection.relegate()||sync__default["default"].postRender(()=>{var _a;(null===(_a=projection.getStack())||void 0===_a?0:_a.members.length)||this.safeToRemove()}));return null}componentDidUpdate(){const {projection}=this.props.visualElement;projection&&(projection.root.didUpdate(),!projection.currentAnimation&&projection.isLead()&&this.safeToRemove())}componentWillUnmount(){const {visualElement,layoutGroup,switchLayoutGroup:promoteContext}=this.props,{projection}=
visualElement;projection&&(projection.scheduleCheckAfterUnmount(),(null===layoutGroup||void 0===layoutGroup?0:layoutGroup.group)&&layoutGroup.group.remove(projection),(null===promoteContext||void 0===promoteContext?0:promoteContext.deregister)&&promoteContext.deregister(projection))}safeToRemove(){const {safeToRemove}=this.props;null===safeToRemove||void 0===safeToRemove?void 0:safeToRemove()}render(){return null}}const defaultScaleCorrectors={borderRadius:Object.assign({},correctBorderRadius,{applyTo:["borderTopLeftRadius",
"borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]}),borderTopLeftRadius:correctBorderRadius,borderTopRightRadius:correctBorderRadius,borderBottomLeftRadius:correctBorderRadius,borderBottomRightRadius:correctBorderRadius,boxShadow:{correct:(latest,$jscomp$destructuring$var93)=>{var {treeScale,projectionDelta}=$jscomp$destructuring$var93,original=latest;$jscomp$destructuring$var93=latest.includes("var(");const cssVariables=[];$jscomp$destructuring$var93&&(latest=latest.replace(cssVariableRegex,
match=>{cssVariables.push(match);return"_$css"}));var shadow=styleValueTypes.complex.parse(latest);if(5<shadow.length)return original;latest=styleValueTypes.complex.createTransformer(latest);original="number"!==typeof shadow[0]?1:0;var xScale=projectionDelta.x.scale*treeScale.x;const yScale=projectionDelta.y.scale*treeScale.y;shadow[0+original]/=xScale;shadow[1+original]/=yScale;xScale=-.5*xScale+.5*yScale+xScale;"number"===typeof shadow[2+original]&&(shadow[2+original]/=xScale);"number"===typeof shadow[3+
original]&&(shadow[3+original]/=xScale);shadow=latest(shadow);if($jscomp$destructuring$var93){let i=0;shadow=shadow.replace("_$css",()=>{const cssVariable=cssVariables[i];i++;return cssVariable})}return shadow}}},layoutFeatures={measureLayout:function(props){const [isPresent,safeToRemove]=usePresence(),layoutGroup=React.useContext(LayoutGroupContext);return React__default["default"].createElement(MeasureLayoutWithContext,Object.assign({},props,{layoutGroup,switchLayoutGroup:React.useContext(SwitchLayoutGroupContext),
isPresent,safeToRemove}))}},borders=["TopLeft","TopRight","BottomLeft","BottomRight"],numBorders=borders.length,asNumber=value=>"string"===typeof value?parseFloat(value):value,easeCrossfadeIn=compress(0,.5,circOut),easeCrossfadeOut=compress(.5,.95,noop),xKeys=["x","scaleX","originX"],yKeys=["y","scaleY","originY"];class NodeStack{constructor(){this.members=[]}add(node){addUniqueItem(this.members,node);node.scheduleRender()}remove(node){removeItem(this.members,node);node===this.prevLead&&(this.prevLead=
void 0);node===this.lead&&(node=this.members[this.members.length-1])&&this.promote(node)}relegate(node){var indexOfNode=this.members.findIndex(member=>node===member);if(0===indexOfNode)return!1;let prevLead;for(;0<=indexOfNode;indexOfNode--){const member=this.members[indexOfNode];if(!1!==member.isPresent){prevLead=member;break}}return prevLead?(this.promote(prevLead),!0):!1}promote(node,preserveFollowOpacity){var _a;const prevLead=this.lead;if(node!==prevLead&&(this.prevLead=prevLead,this.lead=node,
node.show(),prevLead)){prevLead.instance&&prevLead.scheduleRender();node.scheduleRender();node.resumeFrom=prevLead;preserveFollowOpacity&&(node.resumeFrom.preserveOpacity=!0);prevLead.snapshot&&(node.snapshot=prevLead.snapshot,node.snapshot.latestValues=prevLead.animationValues||prevLead.latestValues);if(null===(_a=node.root)||void 0===_a?0:_a.isUpdating)node.isLayoutDirty=!0;({crossfade:node}=node.options);!1===node&&prevLead.hide()}}exitAnimationComplete(){this.members.forEach(node=>{var _a,_b,
_c,_d,_e;null===(_b=(_a=node.options).onExitComplete)||void 0===_b?void 0:_b.call(_a);null===(_e=null===(_c=node.resumingFrom)||void 0===_c?void 0:(_d=_c.options).onExitComplete)||void 0===_e?void 0:_e.call(_d)})}scheduleRender(){this.members.forEach(node=>{node.instance&&node.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}const compareByDepth=(a,b)=>a.depth-b.depth;class FlatTree{constructor(){this.children=[];this.isDirty=!1}add(child){addUniqueItem(this.children,
child);this.isDirty=!0}remove(child){removeItem(this.children,child);this.isDirty=!0}forEach(callback){this.isDirty&&this.children.sort(compareByDepth);this.isDirty=!1;this.children.forEach(callback)}}const transformAxes=["","X","Y","Z"];let id$1=0;const defaultLayoutTransition={duration:.45,ease:[.4,0,.1,1]},DocumentProjectionNode=createProjectionNode({attachResizeListener:(ref,notify)=>addDomEvent(ref,"resize",notify),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,
y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),rootProjectionNode={current:void 0},HTMLProjectionNode=createProjectionNode({measureScroll:instance=>({x:instance.scrollLeft,y:instance.scrollTop}),defaultParent:()=>{if(!rootProjectionNode.current){const documentNode=new DocumentProjectionNode(0,{});documentNode.mount(window);documentNode.setOptions({layoutScroll:!0});rootProjectionNode.current=documentNode}return rootProjectionNode.current},resetTransform:(instance,
value)=>{instance.style.transform=void 0!==value?value:"none"},checkIsScrollRoot:instance=>"fixed"===window.getComputedStyle(instance).position}),featureBundle=Object.assign({},animations$jscomp$0,gestureAnimations,drag,layoutFeatures),motion=createMotionProxy((Component,config)=>createDomMotionConfig(Component,config,featureBundle,createDomVisualElement,HTMLProjectionNode)),m=createMotionProxy(createDomMotionConfig);class PopChildMeasure extends React__namespace.Component{getSnapshotBeforeUpdate(prevProps){const element=
this.props.childRef.current;element&&prevProps.isPresent&&!this.props.isPresent&&(prevProps=this.props.sizeRef.current,prevProps.height=element.offsetHeight||0,prevProps.width=element.offsetWidth||0,prevProps.top=element.offsetTop,prevProps.left=element.offsetLeft);return null}componentDidUpdate(){}render(){return this.props.children}}const PresenceChild=$jscomp$destructuring$var99=>{var {children,initial,isPresent,onExitComplete,custom,presenceAffectsLayout,mode}=$jscomp$destructuring$var99;const presenceChildren=
useConstant(newChildrenMap),id=React.useId();$jscomp$destructuring$var99=React.useMemo(()=>({id,initial,isPresent,custom,onExitComplete:childId=>{presenceChildren.set(childId,!0);for(const isComplete of presenceChildren.values())if(!isComplete)return;onExitComplete&&onExitComplete()},register:childId=>{presenceChildren.set(childId,!1);return()=>presenceChildren.delete(childId)}}),presenceAffectsLayout?void 0:[isPresent]);React.useMemo(()=>{presenceChildren.forEach((_,key)=>presenceChildren.set(key,
!1))},[isPresent]);React__namespace.useEffect(()=>{!isPresent&&!presenceChildren.size&&onExitComplete&&onExitComplete()},[isPresent]);"popLayout"===mode&&(children=React__namespace.createElement(PopChild,{isPresent},children));return React__namespace.createElement(PresenceContext.Provider,{value:$jscomp$destructuring$var99},children)},getChildKey=child=>child.key||"",DeprecatedLayoutGroupContext=React.createContext(null),notify=node=>!node.isLayoutDirty&&node.willUpdate(!1),LayoutGroup=$jscomp$destructuring$var101=>
{var {children,id,inheritId,inherit=!0}=$jscomp$destructuring$var101;void 0!==inheritId&&(inherit=inheritId);$jscomp$destructuring$var101=React.useContext(LayoutGroupContext);var deprecatedLayoutGroupContext=React.useContext(DeprecatedLayoutGroupContext);const [forceRender,key]=useForceUpdate(),context=React.useRef(null);deprecatedLayoutGroupContext=$jscomp$destructuring$var101.id||deprecatedLayoutGroupContext;null===context.current&&((!0===inherit===!0||"id"===inherit)&&deprecatedLayoutGroupContext&&
(id=id?deprecatedLayoutGroupContext+"-"+id:deprecatedLayoutGroupContext),context.current={id,group:!0===inherit?$jscomp$destructuring$var101.group||nodeGroup():nodeGroup()});$jscomp$destructuring$var101=React.useMemo(()=>Object.assign({},context.current,{forceRender}),[key]);return React__namespace.createElement(LayoutGroupContext.Provider,{value:$jscomp$destructuring$var101},children)};let id$jscomp$0=0;const ReorderContext=React.createContext(null),Group=React.forwardRef(function($jscomp$destructuring$var112,
externalRef){var $jscomp$destructuring$var114=Object.assign({},$jscomp$destructuring$var112),children=$jscomp$destructuring$var112.children,as=void 0===$jscomp$destructuring$var112.as?"ul":$jscomp$destructuring$var112.as,axis=void 0===$jscomp$destructuring$var112.axis?"y":$jscomp$destructuring$var112.axis,onReorder=$jscomp$destructuring$var112.onReorder,values=$jscomp$destructuring$var112.values;$jscomp$destructuring$var112=(delete $jscomp$destructuring$var114.children,delete $jscomp$destructuring$var114.as,
delete $jscomp$destructuring$var114.axis,delete $jscomp$destructuring$var114.onReorder,delete $jscomp$destructuring$var114.values,$jscomp$destructuring$var114);$jscomp$destructuring$var114=useConstant(()=>motion(as));const order=[],isReordering=React.useRef(!1);heyListen.invariant(!!values,"Reorder.Group must be provided a values prop");const context={axis,registerItem:(value,layout)=>{layout&&-1===order.findIndex(entry=>value===entry.value)&&(order.push({value,layout:layout[axis]}),order.sort(compareMin))},
updateOrder:(id,offset,velocity)=>{isReordering.current||(id=checkReorder(order,id,offset,velocity),order!==id&&(isReordering.current=!0,onReorder(id.map(getValue).filter(value=>-1!==values.indexOf(value)))))}};React.useEffect(()=>{isReordering.current=!1});return React__namespace.createElement($jscomp$destructuring$var114,Object.assign({},$jscomp$destructuring$var112,{ref:externalRef}),React__namespace.createElement(ReorderContext.Provider,{value:context},children))}),Item=React.forwardRef(function($jscomp$destructuring$var116,
externalRef){var $jscomp$destructuring$var118=Object.assign({},$jscomp$destructuring$var116),children=$jscomp$destructuring$var116.children,style=void 0===$jscomp$destructuring$var116.style?{}:$jscomp$destructuring$var116.style,value=$jscomp$destructuring$var116.value,as=void 0===$jscomp$destructuring$var116.as?"li":$jscomp$destructuring$var116.as,onDrag=$jscomp$destructuring$var116.onDrag;$jscomp$destructuring$var116=void 0===$jscomp$destructuring$var116.layout?!0:$jscomp$destructuring$var116.layout;
$jscomp$destructuring$var118=(delete $jscomp$destructuring$var118.children,delete $jscomp$destructuring$var118.style,delete $jscomp$destructuring$var118.value,delete $jscomp$destructuring$var118.as,delete $jscomp$destructuring$var118.onDrag,delete $jscomp$destructuring$var118.layout,$jscomp$destructuring$var118);const Component=useConstant(()=>motion(as)),context=React.useContext(ReorderContext),point={x:useDefaultMotionValue(style.x),y:useDefaultMotionValue(style.y)},zIndex=useTransform([point.x,
point.y],$jscomp$destructuring$var119=>{var [latestX,latestY]=$jscomp$destructuring$var119;return latestX||latestY?1:"unset"}),measuredLayout=React.useRef(null);heyListen.invariant(!!context,"Reorder.Item must be a child of Reorder.Group");const {axis,registerItem,updateOrder}=context;React.useEffect(()=>{registerItem(value,measuredLayout.current)},[context]);return React__namespace.createElement(Component,Object.assign({},{drag:axis},$jscomp$destructuring$var118,{dragSnapToOrigin:!0,style:Object.assign({},
style,{x:point.x,y:point.y,zIndex}),layout:$jscomp$destructuring$var116,onDrag:(event,gesturePoint)=>{const {velocity}=gesturePoint;velocity[axis]&&updateOrder(value,point[axis].get(),velocity[axis]);onDrag&&onDrag(event,gesturePoint)},onLayoutMeasure:measured=>{measuredLayout.current=measured},ref:externalRef}),children)}),Reorder={Group,Item},domAnimation=Object.assign({},{renderer:createDomVisualElement},animations$jscomp$0,gestureAnimations),domMax=Object.assign({},domAnimation,drag,layoutFeatures,
{projectionNodeConstructor:HTMLProjectionNode}),createScrollMotionValues=()=>({scrollX:motionValue$jscomp$0(0),scrollY:motionValue$jscomp$0(0),scrollXProgress:motionValue$jscomp$0(0),scrollYProgress:motionValue$jscomp$0(0)});class WillChangeMotionValue extends MotionValue{constructor(){super(...arguments);this.members=[];this.transforms=new Set}add(name){let memberName;transformProps.has(name)?(this.transforms.add(name),memberName="transform"):name.startsWith("origin")||name.startsWith("--")||"willChange"===
name||(memberName=camelToDash(name));memberName&&(addUniqueItem(this.members,memberName),this.update())}remove(name){transformProps.has(name)?(this.transforms.delete(name),this.transforms.size||removeItem(this.members,"transform")):removeItem(this.members,camelToDash(name));this.update()}update(){this.set(this.members.length?this.members.join(", "):"auto")}}const wrap=(min,max,v)=>{max-=min;return((v-min)%max+max)%max+min};class DragControls{constructor(){this.componentControls=new Set}subscribe(controls){this.componentControls.add(controls);
return()=>this.componentControls.delete(controls)}start(event,options){this.componentControls.forEach(controls=>{controls.start(event.nativeEvent||event,options)})}}const createDragControls=()=>new DragControls,createObject=()=>({});class StateVisualElement extends VisualElement{build(){}measureInstanceViewportBox(){return createBox()}resetTransform(){}restoreTransform(){}removeValueFromRenderState(){}renderInstance(){}scrapeMotionValuesFromProps(){return{}}getBaseTargetFromProps(){}readValueFromInstance(_state,
key,options){return options.initialState[key]||0}sortInstanceNodePosition(){return 0}makeTargetAnimatableFromInstance($jscomp$destructuring$var127){var $jscomp$destructuring$var129=Object.assign({},$jscomp$destructuring$var127),transition=$jscomp$destructuring$var127.transition;$jscomp$destructuring$var127=$jscomp$destructuring$var127.transitionEnd;$jscomp$destructuring$var129=(delete $jscomp$destructuring$var129.transition,delete $jscomp$destructuring$var129.transitionEnd,$jscomp$destructuring$var129);
const origin=getOrigin($jscomp$destructuring$var129,transition||{},this);checkTargetForNewValues(this,$jscomp$destructuring$var129,origin);return Object.assign({},{transition,transitionEnd:$jscomp$destructuring$var127},$jscomp$destructuring$var129)}}const useVisualState=makeUseVisualState({scrapeMotionValuesFromProps:createObject,createRenderState:createObject}),invertScale=scale=>.001<scale?1/scale:1E5;let hasWarned=!1;exports.AnimatePresence=$jscomp$destructuring$var100=>{var {children,custom,initial=
!0,onExitComplete,exitBeforeEnter,presenceAffectsLayout=!0,mode="sync"}=$jscomp$destructuring$var100;exitBeforeEnter&&(mode="wait",warnOnce(!1,"Replace exitBeforeEnter with mode\x3d'wait'"));let [forceRender]=useForceUpdate();($jscomp$destructuring$var100=React.useContext(LayoutGroupContext).forceRender)&&(forceRender=$jscomp$destructuring$var100);const isMounted=useIsMounted(),filteredChildren=onlyElements(children);let childrenToRender=filteredChildren;const exiting=new Set,presentChildren=React.useRef(childrenToRender),
allChildren=React.useRef(new Map).current,isInitialRender=React.useRef(!0);useIsomorphicLayoutEffect(()=>{isInitialRender.current=!1;updateChildLookup(filteredChildren,allChildren);presentChildren.current=childrenToRender});useUnmountEffect(()=>{isInitialRender.current=!0;allChildren.clear();exiting.clear()});if(isInitialRender.current)return React__namespace.createElement(React__namespace.Fragment,null,childrenToRender.map(child=>React__namespace.createElement(PresenceChild,{key:child.key||"",isPresent:!0,
initial:initial?void 0:!1,presenceAffectsLayout,mode},child)));childrenToRender=[...childrenToRender];const presentKeys=presentChildren.current.map(getChildKey),targetKeys=filteredChildren.map(getChildKey);$jscomp$destructuring$var100=presentKeys.length;for(let i=0;i<$jscomp$destructuring$var100;i++){const key=presentKeys[i];-1===targetKeys.indexOf(key)&&exiting.add(key)}"wait"===mode&&exiting.size&&(childrenToRender=[]);exiting.forEach(key=>{if(-1===targetKeys.indexOf(key)){var child=allChildren.get(key);
if(child){var insertionIndex=presentKeys.indexOf(key);childrenToRender.splice(insertionIndex,0,React__namespace.createElement(PresenceChild,{key:child.key||"",isPresent:!1,onExitComplete:()=>{allChildren.delete(key);exiting.delete(key);const removeIndex=presentChildren.current.findIndex(presentChild=>presentChild.key===key);presentChildren.current.splice(removeIndex,1);exiting.size||(presentChildren.current=filteredChildren,!1!==isMounted.current&&(forceRender(),onExitComplete&&onExitComplete()))},
custom,presenceAffectsLayout,mode},child))}}});childrenToRender=childrenToRender.map(child=>exiting.has(child.key)?child:React__namespace.createElement(PresenceChild,{key:child.key||"",isPresent:!0,presenceAffectsLayout,mode},child));"production"!==env&&"wait"===mode&&1<childrenToRender.length&&console.warn('You\'re attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.');return React__namespace.createElement(React__namespace.Fragment,
null,exiting.size?childrenToRender:childrenToRender.map(child=>React.cloneElement(child)))};exports.AnimateSharedLayout=$jscomp$destructuring$var102=>{({children:$jscomp$destructuring$var102}=$jscomp$destructuring$var102);React__namespace.useEffect(()=>{heyListen.warning(!1,"AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations")},[]);return React__namespace.createElement(LayoutGroup,{id:useConstant(()=>`asl-${id$jscomp$0++}`)},$jscomp$destructuring$var102)};
exports.DeprecatedLayoutGroupContext=DeprecatedLayoutGroupContext;exports.DragControls=DragControls;exports.FlatTree=FlatTree;exports.LayoutGroup=LayoutGroup;exports.LayoutGroupContext=LayoutGroupContext;exports.LazyMotion=function($jscomp$destructuring$var106){var {children,features,strict=!1}=$jscomp$destructuring$var106;const [,setIsLoaded]=React.useState(!isLazyBundle(features)),loadedRenderer=React.useRef(void 0);if(!isLazyBundle(features)){var $jscomp$destructuring$var108=Object.assign({},features);
$jscomp$destructuring$var106=features.renderer;$jscomp$destructuring$var108=(delete $jscomp$destructuring$var108.renderer,$jscomp$destructuring$var108);loadedRenderer.current=$jscomp$destructuring$var106;loadFeatures($jscomp$destructuring$var108)}React.useEffect(()=>{isLazyBundle(features)&&features().then($jscomp$destructuring$var109=>{var $jscomp$destructuring$var111=Object.assign({},$jscomp$destructuring$var109);$jscomp$destructuring$var109=$jscomp$destructuring$var109.renderer;$jscomp$destructuring$var111=
(delete $jscomp$destructuring$var111.renderer,$jscomp$destructuring$var111);loadFeatures($jscomp$destructuring$var111);loadedRenderer.current=$jscomp$destructuring$var109;setIsLoaded(!0)})},[]);return React__namespace.createElement(LazyContext.Provider,{value:{renderer:loadedRenderer.current,strict}},children)};exports.MotionConfig=function($jscomp$destructuring$var103){var $jscomp$destructuring$var105=Object.assign({},$jscomp$destructuring$var103),children=$jscomp$destructuring$var103.children;$jscomp$destructuring$var103=
$jscomp$destructuring$var103.isValidProp;var config=(delete $jscomp$destructuring$var105.children,delete $jscomp$destructuring$var105.isValidProp,$jscomp$destructuring$var105);$jscomp$destructuring$var103&&loadExternalIsValidProp($jscomp$destructuring$var103);config=Object.assign({},React.useContext(MotionConfigContext),config);config.isStatic=useConstant(()=>config.isStatic);$jscomp$destructuring$var105=React.useMemo(()=>config,[JSON.stringify(config.transition),config.transformPagePoint,config.reducedMotion]);
return React__namespace.createElement(MotionConfigContext.Provider,{value:$jscomp$destructuring$var105},children)};exports.MotionConfigContext=MotionConfigContext;exports.MotionContext=MotionContext;exports.MotionValue=MotionValue;exports.PresenceContext=PresenceContext;exports.Reorder=Reorder;exports.SwitchLayoutGroupContext=SwitchLayoutGroupContext;exports.VisualElement=VisualElement;exports.addPointerEvent=addPointerEvent;exports.addScaleCorrector=addScaleCorrector;exports.animate=animate$jscomp$0;
exports.animateVisualElement=animateVisualElement;exports.animationControls=animationControls;exports.animations=animations$jscomp$0;exports.buildTransform=buildTransform;exports.calcLength=calcLength;exports.checkTargetForNewValues=checkTargetForNewValues;exports.clamp=clamp;exports.createBox=createBox;exports.createDomMotionComponent=function(key){return createMotionComponent(createDomMotionConfig(key,{forwardMotionProps:!1},featureBundle,createDomVisualElement,HTMLProjectionNode))};exports.createMotionComponent=
createMotionComponent;exports.delay=delay$jscomp$0;exports.distance=(a,b)=>Math.abs(a-b);exports.distance2D=distance2D;exports.domAnimation=domAnimation;exports.domMax=domMax;exports.filterProps=filterProps;exports.isBrowser=isBrowser;exports.isDragActive=isDragActive;exports.isMotionComponent=isMotionComponent;exports.isMotionValue=isMotionValue;exports.isValidMotionProp=isValidMotionProp;exports.m=m;exports.makeUseVisualState=makeUseVisualState;exports.mix=mix;exports.motion=motion;exports.motionValue=
motionValue$jscomp$0;exports.pipe=(...transformers)=>transformers.reduce(combineFunctions);exports.resolveMotionValue=resolveMotionValue;exports.transform=transform$jscomp$0;exports.unwrapMotionComponent=function(component){if(isMotionComponent(component))return component[motionComponentSymbol]};exports.useAnimation=useAnimationControls;exports.useAnimationControls=useAnimationControls;exports.useAnimationFrame=useAnimationFrame;exports.useCycle=function(...items){const index=React.useRef(0),[item,
setItem]=React.useState(items[index.current]),runCycle=React.useCallback(next=>{index.current="number"!==typeof next?wrap(0,items.length,index.current+1):next;setItem(items[index.current])},[items.length,...items]);return[item,runCycle]};exports.useDeprecatedAnimatedState=function(initialState){const [animationState,setAnimationState]=React.useState(initialState),visualState=useVisualState({},!1),element=useConstant(()=>new StateVisualElement({props:{},visualState},{initialState}));React.useEffect(()=>
{element.mount({});return()=>element.unmount()},[element]);React.useEffect(()=>{element.setProps({onUpdate:v=>{setAnimationState(Object.assign({},v))}})},[setAnimationState,element]);const startAnimation=useConstant(()=>animationDefinition=>animateVisualElement(element,animationDefinition));return[animationState,startAnimation]};exports.useDeprecatedInvertedScale=function(scale){let parentScaleX=useMotionValue(1);var parentScaleY=useMotionValue(1);const visualElement=useVisualElementContext();heyListen.invariant(!(!scale&&
!visualElement),"If no scale values are provided, useInvertedScale must be used within a child of another motion component.");heyListen.warning(hasWarned,"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.");hasWarned=!0;scale?(parentScaleX=scale.scaleX||parentScaleX,parentScaleY=scale.scaleY||parentScaleY):visualElement&&(parentScaleX=visualElement.getValue("scaleX",1),parentScaleY=visualElement.getValue("scaleY",1));scale=useTransform(parentScaleX,invertScale);
parentScaleY=useTransform(parentScaleY,invertScale);return{scaleX:scale,scaleY:parentScaleY}};exports.useDomEvent=useDomEvent;exports.useDragControls=function(){return useConstant(createDragControls)};exports.useElementScroll=function(ref){warnOnce(!1,"useElementScroll is deprecated. Convert to useScroll({ container: ref }).");return useScroll({container:ref})};exports.useForceUpdate=useForceUpdate;exports.useInView=function(ref,$jscomp$destructuring$var126){var {root,margin,amount,once=!1}=void 0===
$jscomp$destructuring$var126?{}:$jscomp$destructuring$var126;const [isInView,setInView]=React.useState(!1);React.useEffect(()=>{if(!(!ref.current||once&&isInView))return dom.inView(ref.current,()=>{setInView(!0);return once?void 0:()=>setInView(!1)},{root:root&&root.current||void 0,margin,amount:"some"===amount?"any":amount})},[root,ref,margin,once]);return isInView};exports.useInstantLayoutTransition=function(){return startTransition};exports.useInstantTransition=function(){const [forceUpdate,forcedRenderCount]=
useForceUpdate();React.useEffect(()=>{sync__default["default"].postRender(()=>sync__default["default"].postRender(()=>instantAnimationState.current=!1))},[forcedRenderCount]);return callback=>{startTransition(()=>{instantAnimationState.current=!0;forceUpdate();callback()})}};exports.useIsPresent=function(){var context=React.useContext(PresenceContext);return null===context?!0:context.isPresent};exports.useIsomorphicLayoutEffect=useIsomorphicLayoutEffect;exports.useMotionTemplate=function(fragments,
...values){const numFragments=fragments.length;return useCombineMotionValues(values,function(){let output="";for(let i=0;i<numFragments;i++)output+=fragments[i],values[i]&&(output+=values[i].get());return output})};exports.useMotionValue=useMotionValue;exports.usePresence=usePresence;exports.useReducedMotion=useReducedMotion;exports.useReducedMotionConfig=function(){const reducedMotionPreference=useReducedMotion(),{reducedMotion}=React.useContext(MotionConfigContext);return"never"===reducedMotion?
!1:"always"===reducedMotion?!0:reducedMotionPreference};exports.useResetProjection=function(){return React__namespace.useCallback(()=>{const root=rootProjectionNode.current;root&&root.resetTree()},[])};exports.useScroll=useScroll;exports.useSpring=function(source,config){config=void 0===config?{}:config;const {isStatic}=React.useContext(MotionConfigContext),activeSpringAnimation=React.useRef(null),value=useMotionValue(isMotionValue(source)?source.get():source);React.useMemo(()=>value.attach((v,set)=>
{if(isStatic)return set(v);activeSpringAnimation.current&&activeSpringAnimation.current.stop();activeSpringAnimation.current=animate$1(Object.assign({},{from:value.get(),to:v,velocity:value.getVelocity()},config,{onUpdate:set}));return value.get()}),[JSON.stringify(config)]);useOnChange(source,v=>value.set(parseFloat(v)));return value};exports.useTime=function(){const time=useMotionValue(0);useAnimationFrame(t=>time.set(t));return time};exports.useTransform=useTransform;exports.useUnmountEffect=useUnmountEffect;
exports.useVelocity=function(value){const velocity=useMotionValue(value.getVelocity());React.useEffect(()=>value.velocityUpdateSubscribers.add(newVelocity=>{velocity.set(newVelocity)}),[value]);return velocity};exports.useViewportScroll=function(){warnOnce(!1,"useViewportScroll is deprecated. Convert to useScroll().");return useScroll()};exports.useVisualElementContext=useVisualElementContext;exports.useWillChange=function(){return useConstant(()=>new WillChangeMotionValue("auto"))};exports.wrap=
wrap;exports.wrapHandler=wrapHandler}
//# sourceMappingURL=module$node_modules$framer_motion$dist$cjs$index.js.map
