import "./cljs_env.js";
shadow$provide.module$node_modules$three$src$objects$Mesh=function(global,require,module,exports){function checkBufferGeometryIntersection(object,material,raycaster,ray,uv,uv2,a,b,c){object.getVertexPosition(a,_vA);object.getVertexPosition(b,_vB);object.getVertexPosition(c,_vC);var pA=_vA,pB=_vB,pC=_vC,point=_intersectionPoint;null===(material.side===_constants.BackSide?ray.intersectTriangle(pC,pB,pA,!0,point):ray.intersectTriangle(pA,pB,pC,material.side===_constants.FrontSide,point))?object=null:
(_intersectionPointWorld.copy(point),_intersectionPointWorld.applyMatrix4(object.matrixWorld),material=raycaster.ray.origin.distanceTo(_intersectionPointWorld),object=material<raycaster.near||material>raycaster.far?null:{distance:material,point:_intersectionPointWorld.clone(),object});object&&(uv&&(_uvA.fromBufferAttribute(uv,a),_uvB.fromBufferAttribute(uv,b),_uvC.fromBufferAttribute(uv,c),object.uv=_Triangle.Triangle.getUV(_intersectionPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new _Vector2.Vector2)),uv2&&
(_uvA.fromBufferAttribute(uv2,a),_uvB.fromBufferAttribute(uv2,b),_uvC.fromBufferAttribute(uv2,c),object.uv2=_Triangle.Triangle.getUV(_intersectionPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new _Vector2.Vector2)),uv={a,b,c,normal:new _Vector.Vector3,materialIndex:0},_Triangle.Triangle.getNormal(_vA,_vB,_vC,uv.normal),object.face=uv);return object}Object.defineProperty(exports,"__esModule",{value:!0});exports.Mesh=void 0;var _Vector=require("module$node_modules$three$src$math$Vector3"),_Vector2=require("module$node_modules$three$src$math$Vector2");
global=require("module$node_modules$three$src$math$Sphere");module=require("module$node_modules$three$src$math$Ray");var _Matrix=require("module$node_modules$three$src$math$Matrix4"),_Object3D=require("module$node_modules$three$src$core$Object3D"),_Triangle=require("module$node_modules$three$src$math$Triangle"),_constants=require("module$node_modules$three$src$constants"),_MeshBasicMaterial=require("module$node_modules$three$src$materials$MeshBasicMaterial"),_BufferGeometry=require("module$node_modules$three$src$core$BufferGeometry");
const _inverseMatrix=new _Matrix.Matrix4,_ray=new module.Ray,_sphere=new global.Sphere,_vA=new _Vector.Vector3,_vB=new _Vector.Vector3,_vC=new _Vector.Vector3,_tempA=new _Vector.Vector3,_morphA=new _Vector.Vector3,_uvA=new _Vector2.Vector2,_uvB=new _Vector2.Vector2,_uvC=new _Vector2.Vector2,_intersectionPoint=new _Vector.Vector3,_intersectionPointWorld=new _Vector.Vector3;class Mesh extends _Object3D.Object3D{constructor(geometry=new _BufferGeometry.BufferGeometry,material=new _MeshBasicMaterial.MeshBasicMaterial){super();
this.isMesh=!0;this.type="Mesh";this.geometry=geometry;this.material=material;this.updateMorphTargets()}copy(source,recursive){super.copy(source,recursive);void 0!==source.morphTargetInfluences&&(this.morphTargetInfluences=source.morphTargetInfluences.slice());void 0!==source.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},source.morphTargetDictionary));this.material=source.material;this.geometry=source.geometry;return this}updateMorphTargets(){var morphAttributes=this.geometry.morphAttributes,
keys=Object.keys(morphAttributes);if(0<keys.length&&(morphAttributes=morphAttributes[keys[0]],void 0!==morphAttributes)){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(let m=0,ml=morphAttributes.length;m<ml;m++)keys=morphAttributes[m].name||String(m),this.morphTargetInfluences.push(0),this.morphTargetDictionary[keys]=m}}getVertexPosition(vert,target){var geometry=this.geometry;const morphPosition=geometry.morphAttributes.position,morphTargetsRelative=geometry.morphTargetsRelative;
target.fromBufferAttribute(geometry.attributes.position,vert);geometry=this.morphTargetInfluences;if(morphPosition&&geometry){_morphA.set(0,0,0);for(let i=0,il=morphPosition.length;i<il;i++){const influence=geometry[i];0!==influence&&(_tempA.fromBufferAttribute(morphPosition[i],vert),morphTargetsRelative?_morphA.addScaledVector(_tempA,influence):_morphA.addScaledVector(_tempA.sub(target),influence))}target.add(_morphA)}this.isSkinnedMesh&&this.boneTransform(vert,target);return target}raycast(raycaster,
intersects){var geometry=this.geometry;const material=this.material;var matrixWorld=this.matrixWorld;if(void 0!==material&&(null===geometry.boundingSphere&&geometry.computeBoundingSphere(),_sphere.copy(geometry.boundingSphere),_sphere.applyMatrix4(matrixWorld),!1!==raycaster.ray.intersectsSphere(_sphere)&&(_inverseMatrix.copy(matrixWorld).invert(),_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix),null===geometry.boundingBox||!1!==_ray.intersectsBox(geometry.boundingBox)))){var index=geometry.index,
position=geometry.attributes.position;matrixWorld=geometry.attributes.uv;var uv2=geometry.attributes.uv2,groups=geometry.groups;geometry=geometry.drawRange;if(null!==index)if(Array.isArray(material))for(let i=0,il=groups.length;i<il;i++){position=groups[i];var groupMaterial=material[position.materialIndex];var intersection=Math.max(position.start,geometry.start);var end=Math.min(index.count,Math.min(position.start+position.count,geometry.start+geometry.count));for(let j=intersection,jl=end;j<jl;j+=
3){intersection=index.getX(j);end=index.getX(j+1);const c=index.getX(j+2);if(intersection=checkBufferGeometryIntersection(this,groupMaterial,raycaster,_ray,matrixWorld,uv2,intersection,end,c))intersection.faceIndex=Math.floor(j/3),intersection.face.materialIndex=position.materialIndex,intersects.push(intersection)}}else{groups=Math.max(0,geometry.start);geometry=Math.min(index.count,geometry.start+geometry.count);for(let i=groups,il=geometry;i<il;i+=3)if(geometry=index.getX(i),groups=index.getX(i+
1),position=index.getX(i+2),intersection=checkBufferGeometryIntersection(this,material,raycaster,_ray,matrixWorld,uv2,geometry,groups,position))intersection.faceIndex=Math.floor(i/3),intersects.push(intersection)}else if(void 0!==position)if(Array.isArray(material))for(let i=0,il=groups.length;i<il;i++){index=groups[i];groupMaterial=material[index.materialIndex];intersection=Math.max(index.start,geometry.start);end=Math.min(position.count,Math.min(index.start+index.count,geometry.start+geometry.count));
for(let j=intersection,jl=end;j<jl;j+=3)if(intersection=checkBufferGeometryIntersection(this,groupMaterial,raycaster,_ray,matrixWorld,uv2,j,j+1,j+2))intersection.faceIndex=Math.floor(j/3),intersection.face.materialIndex=index.materialIndex,intersects.push(intersection)}else{index=Math.max(0,geometry.start);geometry=Math.min(position.count,geometry.start+geometry.count);for(let i=index,il=geometry;i<il;i+=3)if(intersection=checkBufferGeometryIntersection(this,material,raycaster,_ray,matrixWorld,uv2,
i,i+1,i+2))intersection.faceIndex=Math.floor(i/3),intersects.push(intersection)}}}}exports.Mesh=Mesh}
//# sourceMappingURL=module$node_modules$three$src$objects$Mesh.js.map
