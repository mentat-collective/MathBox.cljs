{"version":3,"sources":["sci/impl/interpreter.cljc"],"mappings":"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","names":["sci.impl.interpreter/eval-form","ctx","form","cljs.core/seq?","cljs.core._EQ_","cljs.core/first","exprs","cljs.core/rest","ret","cljs.core/seq","G__76195","G__76196","upper-sym","cljs.core.gensym","cb","cljs.core/volatile!","cljs.core.assoc","analyzed","sci.impl.analyzer.analyze","binding-array-size","cljs.core/count","cljs.core/deref","cljs.core.get_in","bindings","cljs.core.object_array","sci.impl.types/EvalForm","G__76201","G__76202","e76203","sci.impl.types/eval","js/Error","e","sci.impl.utils.rethrow_with_location_of_node","e76204","cljs.core/vreset!","sci.impl.utils/eval-form-state","sci.impl.interpreter/eval-string*","s","sci.impl.vars/push-thread-bindings","sci.impl.vars/pop-thread-bindings","sci.impl.utils/current-ns","reader","cljs.tools.reader.reader_types.indexing_push_back_reader","cljs.tools.reader.reader_types.string_push_back_reader","expr","sci.impl.parser.parse_next","cljs.core/keyword-identical?","sci.impl.parser/eof","sci.impl.utils/eval-string*","var_args","G__76210","sci.impl.interpreter/eval-string","sci.impl.interpreter.eval_string","opts","init-ctx","sci.impl.opts/init"],"sourcesContent":["(ns sci.impl.interpreter\n  {:no-doc true}\n  (:refer-clojure :exclude [destructure macroexpand macroexpand-1])\n  (:require\n   [clojure.tools.reader.reader-types :as r]\n   [sci.impl.analyzer :as ana]\n   [sci.impl.opts :as opts]\n   [sci.impl.parser :as p]\n   [sci.impl.types :as types]\n   [sci.impl.utils :as utils]\n   [sci.impl.vars :as vars]))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(defn eval-form [ctx form]\n  ;; (.println System/err \"form\")\n  ;; (.println System/err form)\n  (if (seq? form)\n    (if (= 'do (first form))\n      (loop [exprs (rest form)\n             ret nil]\n        (if (seq exprs)\n          (recur\n           (rest exprs)\n           (eval-form ctx (first exprs)))\n          ret))\n      (let [;; take care of invocation array for let\n            upper-sym (gensym)\n            cb (volatile! {upper-sym {0 {:syms {}}}})\n            ctx (assoc ctx\n                       :parents [upper-sym 0]\n                       :closure-bindings cb)\n            analyzed (ana/analyze ctx form true)\n            binding-array-size (count (get-in @cb [upper-sym 0 :syms]))\n            bindings (object-array binding-array-size)]\n        (if (instance? #?(:clj sci.impl.types.EvalForm\n                          :cljs sci.impl.types/EvalForm) analyzed)\n          (eval-form ctx (types/getVal analyzed))\n          (try (types/eval analyzed ctx bindings)\n               (catch #?(:clj Throwable :cljs js/Error) e\n                 (utils/rethrow-with-location-of-node ctx bindings e analyzed))))))\n    (let [upper-sym (gensym)\n          cb (volatile! {upper-sym {0 {:syms {}}}})\n          ctx (assoc ctx\n                     :parents [upper-sym 0]\n                     :closure-bindings cb)\n          analyzed (ana/analyze ctx form)\n          binding-array-size (count (get-in @cb [upper-sym 0 :syms]))\n          bindings (object-array binding-array-size)]\n      (try (types/eval analyzed ctx bindings)\n           (catch #?(:clj Throwable :cljs js/Error) e\n             (utils/rethrow-with-location-of-node ctx bindings e analyzed))))))\n\n(vreset! utils/eval-form-state eval-form)\n\n(defn eval-string* [ctx s]\n  (vars/with-bindings {utils/current-ns @utils/current-ns}\n    (let [reader (r/indexing-push-back-reader (r/string-push-back-reader s))]\n      (loop [ret nil]\n        (let [expr (p/parse-next ctx reader)]\n          (if (utils/kw-identical? p/eof expr)\n            ret\n            (let [ret (eval-form ctx expr)]\n              (recur ret))))))))\n\n(vreset! utils/eval-string* eval-string*)\n\n;;;; Called from public API\n\n(defn eval-string\n  ([s] (eval-string s nil))\n  ([s opts]\n   (let [init-ctx (opts/init opts)\n         ret (eval-string* init-ctx s)]\n     ret)))\n\n;;;; Scratch\n\n(comment\n  (eval-string \"((fn f [x] (if (< x 3) (recur (inc x)) x)) 0)\")\n  )\n"]}